[ { "title": "scale-out 된 상태에서 어떻게 세션을 관리할까? -sticky session / 세션 클러스터링 / 세션 스토리지 분리", "url": "/posts/multiserver-session/", "categories": "study", "tags": "IT", "date": "2022-04-18 13:05:00 +0900", "snippet": "예전에 면접볼 때 질문을 너무 못했던 바로 그 주제… ㅠㅠ.. 면접보고나서 바로 플젝 회의할때 그 주제가 나와서 땅을 치고 후회했드랩죠…그래도 머 킵고잉해야하니까 용기내서 간단하게 정리해봅니당그때 면접때 MSA 아키텍쳐 이야기를 많이 하면서 서버 여러대로 scael out 된 상황을 가정했었다. 그리고 jwt 통해서 로그인 기능 구현하는 이야기를 나눴었는데, 그렇다면 당연히 scale out한 상황에서 세션 일관성을 어떻게 유지할지가 중요하다.1. scale out 상황에서의 세션 관리scale out : 트래픽 증가 등의 이유로 서버 장비를 추가하는 것 (같은 일을 하는 서버를 추가하기에 수평적으로 확장) 이 상황이면 같은 일을 하는 서버가 여러대 있고, 앞에서 이에 트래픽을 분배해주는 load balancer 가 있다.로그인후 세션에 토큰 등을 넣어서 로그인 상태를 관리한다고 하면, 세션은 서버에 저장되기에 사용자가 다른 서버에 붙어도 같은 값을 이용할 수 있도록 하는게 중요하다. 즉 어떻게 세션을 공유해 사용하고자 하는가에 대한 내용이다.2. 세션 공유의 방법1) sticky session말 그대로 고정된 세션이다. 처음 세션을 생성할때, 어떤 서버에 세션을 만들었는지 쿠키에 보내준다.클라이언트는 쿠키에 연결됐었던 서버 정보를 가지고 재요청하게되고, lb 는 이걸 보고 그 서버에 보내준다.그럼 한 사용자는 한 서버에만 계속 붙게 되기 때문에 다른 서버에 붙어서 세션을 사용하지 못할까봐 걱정할 필요가 없다.단점 같은 사용자는 같은 서버에만 붙음 -&amp;gt; 트래픽 분산 안됨. 특정 서버 fali down 시 그 서버에 붙었던 사용자 세션 다 날아감. scale out의 장점을 누리지 못한다.2) session clustering (세션 클러스터링)클러스터링 : 여러 대를 하나처럼 사용할 수 있도록 하는 것각 서버의 세션을 다 복사 (all to all) 하거나 primary-seconday 식으로 복사해서 결국은 어느 서버에 붙어도 세션 사용할 수 있도록 한다.단점 세션 붙을 때마다 복사하는데 자원이 소모된다.3) 세션 스토리지 분리방법 3은 아예 공통으로 사용할 세션 스토리지를 분리시키는 것이다.이렇게 하면 세션은 각 서버에 종속되지 않는다.대신 세션을 저장하고 읽어오고 하는게 많아지기에 빈번한 읽기쓰기에 맞는 스토리지가 필요하다.즉, 보통의 rdb 같은 디스크 IO를 하는 스토리지는 성능에 무리가 갈 수 있기에 빠르게 읽고 쓰기 쉬운 인메모리 db를 사용한다.이게 redis 를 세션스토리지로 주로 사용하는 이유이다." }, { "title": "leetcode 풀이 저장소 안내", "url": "/posts/leetcode-manual/", "categories": "leetcode", "tags": "IT, algorithm", "date": "2022-04-17 13:05:00 +0900", "snippet": "더이상 릿코드 풀이를 쓰는건 무의미할 거 같당.내 릿코드 풀이 저장소는 여기 입니당.주석도 써놓았으니 해버룩~~~~" }, { "title": "DB-인덱스에 대하여, clustered index nonclustered index", "url": "/posts/index/", "categories": "study", "tags": "IT, db", "date": "2022-04-15 13:05:00 +0900", "snippet": "DB 공부하다가 남기는 기록. 쿼리를 빠르게 돌리기 위해서 인덱스, 쿼리 힌트 사용하기가 있는데 정확히 그게 뭐고 어떻게 사용하는지 정리1. 인덱스란?데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조이다.테이블 안의 데이터가 많다면 풀스캔을 해서 조회하면 시간이 너무 많이 걸림.2. 인덱스의 내부 구조B-Tree (balanced tree)트리 구조로 균형있게 높이를 유지하도록 밸런스 맞춰서 저장한다. 노드안의 키는 정렬되어있다.일반적인 트리는, 트리가 편향되어있고 최악의 경우를 생각하면 O(n) 의 시간이 걸린다. 밸런스가 맞춰져있다면 O(logN) 의 시간이 보장된다.동작 방법 루트 노드부터 탐색한다. 노드의 키를 순회하면서 찾으면 탐색 종료한다. 못 찾으면 어떤 이웃한 두 키 사이의 값인지 보고, 그렇다면 자식 노드로 내려간다. 마지막 노드까지 반복한다.3. 인덱스의 종류클러스터드 인덱스인덱스 - 데이터가 묶음으로 존재하는 것으로, 값을 찾기는 빠르지만 새로운 인덱스를 삽입해야한다면 정렬되어있는 다른 인덱스를 다 옮겨줘야해서 시간이 많이 소요된다. PK 를 생각해보면 됨 순서대로 정렬해놓음. 한 테이블에 하나만 존재한다. 범위 검색에 좋다 테이블 그 자체가 인덱스여서 따로 인덱스 저장 공간 필요하지 않다. 유니크 키와 Pk 를 혼동하지 않아야한다. 유니크해야한다고 무조건 pk 걸면 성능상에 문제가 생길 수 있다.(회원테이블에 메일주소를 pk 주는 경우 등) 논클러스터드 인덱스순서에 상관없이 인덱스만 저장한다. 추가 저장 공간이 따로 필요하며 insert 시 인덱스를 생성하는 작업은 필요하다. 인덱스에서 데이터의 위치를 확인하고 다시 한번 그 데이터 접근하는 방식이다. 통상적으로 거는 인덱스 생각하면 됨 인덱스 기준으로 정렬되어 별도의 공간에 저장되어있음. 테이블과 매핑되어있어 인덱스에서 찾아서 테이블 가서 가져오는 것. (테이블 블럭의 주소를 가지고 있는 것처럼) where 절, order by 절에 자주 들어가는 내용을 걸어두는게 좋다. 여러 컬럼을 조합해서 인덱스로 구성할 수도 있다. 이 때 조합의 순서가 중요하다. 한 테이블에 여러개 가능하다. 그러나 인덱스를 마구잡이로 생성하면 insert 나 update 에서 속도가 느려질 수 있다. 어느 자리에 insert 해야할지 확인하고 인덱스에도 insert 해줘야하니까 느려진다.또 인덱스는 update, delete 해도 사용 안함 처리만 하고 그대로 가지고 있어서 쓸데없이 볼륨만 커지는 경우가 있다." }, { "title": "leetcode 풀이 - move zeros", "url": "/posts/leetcode8/", "categories": "leetcode", "tags": "IT, java, codingtest, leetcode", "date": "2022-04-12 15:05:00 +0900", "snippet": "문제Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements.Note that you must do this in-place without making a copy of the array.Example 1:Input: nums = [0,1,0,3,12]Output: [1,3,12,0,0]Example 2:Input: nums = [0]Output: [0]Constraints:1 &amp;lt;= nums.length &amp;lt;= 104-231 &amp;lt;= nums[i] &amp;lt;= 231 - 1Follow up: Could you minimize the total number of operations done?내 풀이class Solution { public void moveZeroes(int[] nums) { // 포인터 두 개를 사용해 배열을 한번만 돌도록 한다. //sol: using two pointer int first =0; int second =1; // saved value for switching index // 자리 바꿀 때 임시로 값 저장할 변수 int saved =0; while(second &amp;lt; nums.length){ // 0 이 0 아닌 숫자 앞에 있는 경우만 자리 바꾼다. if(nums[first]==0 &amp;amp;&amp;amp; nums[second]!=0){ // if zero is in front of non-zero value, switch saved = nums[first]; nums[first]=nums[second]; nums[second] = saved; ++first; ++second; // 0 아닌 수가 앞에 있다면 인덱스 증가시킴 (자리 바꿀 필요 없음) }else if(nums[first]!=0){ // if non zero is in front of zero, you don&#39;t have to switch. Just move two pointers forward. ++first; ++second; // 0 끼리 비교 -&amp;gt; 첫번째 0 자리 기억하기 위해 두번째 포인터만 증가시킴 }else{ // if you compare two zero numbers, move second pointer forward to remember first zero number&#39;s index. ++second; } } }}" }, { "title": "leetcode 풀이 - plus one", "url": "/posts/leetcode7/", "categories": "leetcode", "tags": "IT, java, codingtest, leetcode", "date": "2022-04-12 15:05:00 +0900", "snippet": "문제You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0’s.Increment the large integer by one and return the resulting array of digits.Example 1:Input: digits = [1,2,3]Output: [1,2,4]Explanation: The array represents the integer 123.Incrementing by one gives 123 + 1 = 124.Thus, the result should be [1,2,4].Example 2:Input: digits = [4,3,2,1]Output: [4,3,2,2]Explanation: The array represents the integer 4321.Incrementing by one gives 4321 + 1 = 4322.Thus, the result should be [4,3,2,2].Example 3:Input: digits = [9]Output: [1,0]Explanation: The array represents the integer 9.Incrementing by one gives 9 + 1 = 10.Thus, the result should be [1,0].Constraints:1 &amp;lt;= digits.length &amp;lt;= 1000 &amp;lt;= digits[i] &amp;lt;= 9digits does not contain any leading 0’s.내 풀이class Solution { public int[] plusOne(int[] digits) { //sol : if the last digit is not 9, just plue one to the last digits and return. // if the last digit is 9, check the previous digit by recursive function. // 마지막 숫자가 9가 아니라면 그냥 +1 해서 리턴, 9 라면 재귀함수로 앞의 숫자들 검사해간다. (앞의 단위 숫자가 9 인경우 또 다음 앞 숫자로 올림 해야하기에 재귀 함수 사용) // 공통 로직: 마지막 숫자에 +1 // common logic : plus one to the last digit. digits[digits.length-1] = digits[digits.length-1] +1; // 마지막 숫자 +1 != 10 -&amp;gt; 숫자 올림 필요 없어서 바로 리턴 // If the last digit + 1 does not exceed 10, return it immediately. if(digits[digits.length-1]!=10){ return digits; }else{ // 한칸씩 앞으로 가면서 숫자 올림 필요한지 확인 //check recursively. (example input : {9,9,9} -&amp;gt; {1,0,0,0}) digits = isUpscale(digits, digits.length-1); } return digits; } //recursive function that check if this index&#39;s digit + 1 exceeds 10. // 인덱스와 배열 넣어 앞 단위 숫자 검사하는 함수 public int[] isUpscale(int[] digits, int index){ if(digits[index]==10){ digits[index]=0; if(index -1 &amp;gt;= 0){ // if it has still previous digit, recursive search. /// 앞의 단위 숫자 남아있으면 계속 재귀 돌림 digits[index-1]=digits[index-1]+1; digits=isUpscale(digits, index-1); }else{ // if the fisrt number (index 0) is 10, make answer array&#39;s size increse and deep copy of last digits. 0번째 숫자가 10되면 자릿수 올림해야하기에 배열 크기 늘리고 딥카피 int[] newDigits = new int[digits.length+1]; newDigits[0]=1; for(int i=1; i&amp;lt;digits.length+1; i++){ newDigits[i]=digits[i-1]; } return newDigits; } } return digits; }}" }, { "title": "leetcode 풀이 - intersection of two arrays 2", "url": "/posts/leetcode6/", "categories": "leetcode", "tags": "IT, java, codingtest, leetcode", "date": "2022-04-12 15:05:00 +0900", "snippet": "문제Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.Example 1:Input: nums1 = [1,2,2,1], nums2 = [2,2]Output: [2,2]Example 2:Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]Output: [4,9]Explanation: [9,4] is also accepted.Constraints:1 &amp;lt;= nums1.length, nums2.length &amp;lt;= 10000 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 1000Follow up:What if the given array is already sorted? How would you optimize your algorithm?What if nums1’s size is small compared to nums2’s size? Which algorithm is better?What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?내 풀이class Solution { public int[] intersect(int[] nums1, int[] nums2) { //Runtime: 3 ms //Memory Usage: 43.5 MB //solution: sort array first and use two pointers to compare Arrays.sort(nums1); Arrays.sort(nums2); int nums1Index = 0; int nums2Index = 0; List&amp;lt;Integer&amp;gt; answerList = new ArrayList&amp;lt;&amp;gt;(); while(nums1Index &amp;lt; nums1.length &amp;amp;&amp;amp; nums2Index &amp;lt; nums2.length){ if(nums1[nums1Index] == nums2[nums2Index]){ // if it has the same value, save and move forward both pointers answerList.add(nums1[nums1Index]); ++nums1Index; ++nums2Index; }else if(nums1[nums1Index]&amp;gt;nums2[nums2Index]){ // if one array&#39;s value is greater that another, move pointer forward, because it is not worth to compare later values (since it is sorted) ++nums2Index; }else if(nums1[nums1Index]&amp;lt;nums2[nums2Index]){ ++nums1Index; } } int[] answer = new int[answerList.size()]; //list to array for(int i=0; i&amp;lt;answer.length; i++){ answer[i] = answerList.get(i); } return answer; }}" }, { "title": "leetcode 풀이 - Single number", "url": "/posts/leetcode5/", "categories": "leetcode", "tags": "IT, java, codingtest, leetcode", "date": "2022-04-12 15:05:00 +0900", "snippet": "문제Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.You must implement a solution with a linear runtime complexity and use only constant extra space.Example 1:Input: nums = [2,2,1]Output: 1Example 2:Input: nums = [4,1,2,1,2]Output: 4Example 3:Input: nums = [1]Output: 1내 풀이class Solution { public int singleNumber(int[] nums) { //Runtime: 11 ms //Memory Usage: 50.6 MB // 배열 길이 1 이면 무조건 첫번째 숫자 리턴 // array length = 1 -&amp;gt; always return 0th number. if(nums.length == 1){ return nums[0]; } //정렬 //sort array Arrays.sort(nums); // 같은 숫자는 두 개만 들어있고 싱글 넘버는 하나 뿐이기에 정렬 후에는 홀수 인덱스만 비교해보면 된다. // Because the same numbers only contains twice and the single number contains once, you just search only odd indexes after sorting array. // after you sort array // index 0 -&amp;gt; only compare with the next number // odd indexes (except the last index) -&amp;gt; compare with both sides number // if a single number doesn&#39;t find after finishing for-loop , return the last index without comparing // only for odd indexes // 홀수 인덱스만 비교 (마지막 값 제외) for(int i=0; i&amp;lt;nums.length-2; i+=2){ if(i==0){ if(nums[i]!=nums[i+1]) return nums[i]; //0번째면 다음 값하고만 비교 / if index is zero, compare only with the next value. }else{ if((nums[i]!=nums[i+1])&amp;amp;&amp;amp;(nums[i]!=nums[i-1])){ // 0 아닌 홀수 인덱스는 양 옆값이랑 비교 // if index is not zero and odd, compare both sides. return nums[i]; } } } return nums[nums.length-1]; }}" }, { "title": "Bit operation", "url": "/posts/bit-manipulation/", "categories": "study", "tags": "IT, java, algorithm", "date": "2022-04-12 13:05:00 +0900", "snippet": "알고리즘 문제 풀다가 공부한 bit operation 정리1. Bit operation비트 단위의 연산에 대해서 공부하기 위해서는 우선 비트가 뭔지 알아야한다.Bit 란?컴퓨터에서 0 혹은 1의 binary digit을 저장하는 가장 작은 단위의 데이터이다. 너무 작은 단위이기에 하나의 bit 씩 사용되기 보단 byte처럼 bit 의 묶음이 주로 사용된다.가장 많이 사용되는 1 byte는 8 bit 이다.java 의 데이터 자료형의 bit 수는? byte : 8 bits, 2^7-1(양수+0), 2^7 (음수) short : 2 bytes = 8*2 bits = 16bits int : 4byte = 4*8 bits = 32 bits 이다. 32 bits 로 표현 가능한 수는 2^32 이지만, 맨 앞의 비트는 부호를 표기하도록 하여 아래와 같은 범위의 수 해결할 수 있다. 2^31-1 (양수 + 0) ~ 2^31 (음수) long : 8 byte = 8*8 bits =64 bits 이다.결국 우리가 32 같은 10진수를 저장한다고 쳐도 컴퓨터한테는 우리가 선언한 데이터 자료형에 따라서 긴 bit 방에 2진수를 넣는것과 같다.그렇기 때문에 숫자를 통해서 bit 연산을 할 수 있다.Bit Operation 종류AND 연산 (기호 : &amp;amp;)X &amp;amp; Y : X 와 Y 가 모두 1이어야 1, 아니면 0OR 연산 (기호 : |)X | Y : X , Y 둘 중에 1개만 1이 있으면 1, 둘다 0인 경우만 0XOR 연산 (기호 : ^)X^Y : 둘이 다르면 1, 같으면 0NOT 연산 (기호 : ~)~X : 모든 비트 반대로, 1 이면 0 , 0 이면 1shift 연산 (기호 : 왼쪽으로 shift 시 «  오른쪽으로 shift 시»)ex: 1«3 -&amp;gt; 1000왼쪽 shift는 왼쪽으로 밀고 뒤에는 다 0으로 채우기에 큰 문제가 없지만, 오른쪽 shift의 경우는 부호 파트인 첫번째 비트를 어떻게 할건지가 중요하다. “ »&amp;gt; “ : 부호를 무시하고 그냥 밀기 “ » “ : 부호를 유지하고 밀기 이다." }, { "title": "leetcode 풀이 - Contains Duplicate", "url": "/posts/leetcode4/", "categories": "leetcode", "tags": "IT, java, codingtest", "date": "2022-04-06 15:05:00 +0900", "snippet": "문제Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.Example 1:Input: nums = [1,2,3,1]Output: trueExample 2:Input: nums = [1,2,3,4]Output: falseExample 3:Input: nums = [1,1,1,3,3,4,3,2,4,2]Output: true내 풀이class Solution { public boolean containsDuplicate(int[] nums) { // 풀이법: 중복을 허용하지 않는 HashSet 의 특성을 사용해, 배열을 HashSet에 복사후 크기를 비교한다. //using HashSet&#39;s charcteristic (unable to save duplicated values) HashSet&amp;lt;Integer&amp;gt; removeDuplicate = new HashSet&amp;lt;&amp;gt;(); for(int i=0; i&amp;lt;nums.length; i++){ removeDuplicate.add(nums[i]); } // 둘이 크기가 다르다면 중복 값 있는것이기에 return true //if two objects have different size, it means the array has duplicated values. Return true. if(removeDuplicate.size() != nums.length){ return true; } return false; }}" }, { "title": "leetcode 풀이 - Rotate Array", "url": "/posts/leetcode3/", "categories": "leetcode", "tags": "IT, java, codingtest", "date": "2022-04-06 15:05:00 +0900", "snippet": "문제Given an array, rotate the array to the right by k steps, where k is non-negative.Example 1:Input: nums = [1,2,3,4,5,6,7], k = 3Output: [5,6,7,1,2,3,4]Explanation:rotate 1 steps to the right: [7,1,2,3,4,5,6]rotate 2 steps to the right: [6,7,1,2,3,4,5]rotate 3 steps to the right: [5,6,7,1,2,3,4]Example 2:Input: nums = [-1,-100,3,99], k = 2Output: [3,99,-1,-100]Explanation: rotate 1 steps to the right: [99,-1,-100,3]rotate 2 steps to the right: [3,99,-1,-100]내 풀이class Solution { public void rotate(int[] nums, int k) { // 풀이법: 배열 크기보다 회전 수가 많다면 배열 크기보다 같거나 작도록 수정한다. (한 바퀴 돌아서 반영되지 않기에) // 회전된 배열에서 인덱스가 원래 배열에서 어떤 인덱스인지 역으로 계산한다. // if added index is larger than array&#39;s size, adjust it to fit it. // example, [0,1,2,3,4], k=3 -&amp;gt; [2,3,4,0,1] 2&#39;s index : 2-&amp;gt;5 (rotate k times)-&amp;gt; 5-5(array&#39;s length) =0 int[] rotated = new int[nums.length]; //if K is larger than array&#39;s length, make it smaller or equal to array&#39;s length if(nums.length &amp;lt; k){ while(nums.length &amp;lt;k){ k -= nums.length; } } // rotated index -&amp;gt; find original index // 회전 후 인덱스 = 원래 인덱스 + 회전수 / (원래 인덱스 +회전수가 배열 크기보다 크다면) 원래 인덱스 + 회전수 - 배열 길이 // 역산하여 회전 후 배열에 들어갈 값의 원래 배열의 인덱스를 알아낸다. int index =0; for(int i=0; i&amp;lt;nums.length; i++){ index= (i-k) &amp;lt;0 ? i-k+nums.length : i-k; rotated[i] = nums[index]; } // copy rotated array to original array // 원래 배열을 재정렬 해야하기에 회전 후 값 저장한 배열을 복사한다. for(int i=0; i&amp;lt;nums.length; i++){ nums[i] = rotated[i]; } }}" }, { "title": "leetcode 풀이 - Best Time to Buy and Sell Stock II", "url": "/posts/leetcode2/", "categories": "leetcode", "tags": "IT, java, codingtest, leetcode", "date": "2022-04-06 15:05:00 +0900", "snippet": "문제You are given an integer array prices where prices[i] is the price of a given stock on the ith day.On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.Find and return the maximum profit you can achieve.Example 1:Input: prices = [7,1,5,3,6,4]Output: 7Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.Total profit is 4 + 3 = 7.Example 2:Input: prices = [1,2,3,4,5]Output: 4Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.Total profit is 4.Example 3:Input: prices = [7,6,4,3,1]Output: 0Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.내 풀이class Solution { public int maxProfit(int[] prices) { //풀이법 : 첫번째 값부터 비교하면서 최저값 인덱스, 최대값 인덱스 저장한다. 최대값 인덱스는 그 다음값보다 큰지도 비교한다. (다음 값이 더 크면 다음에 파는게 더 큰 이득이니까) // 최댓값 인덱스가 최솟값 인덱스보다 큰 경우, 최소에 사서 최대에 팔 수 있기에 프로핏 값 계산한다. //solution : save the lowest, highest price&#39;s index. The highest price&#39;s index should be larger than the next index&#39;s price. //if the highest price&#39;s index is larger than the lowest price&#39;s index , calculate profit. int lowIndex =0; int highIndex=0; int profit=0; for(int i =0; i&amp;lt;prices.length; i++){ if(prices[i]&amp;lt;prices[lowIndex]){ lowIndex=i; }else if(prices[i]&amp;gt;prices[lowIndex]){ //if price is higher than the lowest price and tomorrow&#39;s price, it is the best to sell today and buy another stock tomorrow. if(i!=prices.length-1){ //check if today is the last day. (If it does, don&#39;t have to compare with tomorrow&#39;s price) if(prices[i]&amp;gt;prices[i+1]){ highIndex=i; } }else{ highIndex=i; } } if((highIndex &amp;gt; lowIndex)){ profit += prices[highIndex]-prices[lowIndex]; lowIndex=i+1; } } return profit; }}" }, { "title": "leetcode 풀이 - Remove Duplicates from Sorted Array", "url": "/posts/leetcode1/", "categories": "leetcode", "tags": "IT, java, codingtest", "date": "2022-04-06 15:05:00 +0900", "snippet": "문제Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same.Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.Return k after placing the final result in the first k slots of nums.Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.Custom Judge:The judge will test your solution with the following code:int[] nums = […]; // Input arrayint[] expectedNums = […]; // The expected answer with correct lengthint k = removeDuplicates(nums); // Calls your implementationassert k == expectedNums.length;for (int i = 0; i &amp;lt; k; i++) { assert nums[i] == expectedNums[i];}If all assertions pass, then your solution will be accepted.Example 1:Input: nums = [1,1,2]Output: 2, nums = [1,2,_]Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).Example 2:Input: nums = [0,0,1,1,1,2,2,3,3,4]Output: 5, nums = [0,1,2,3,4,,,,,_]Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.It does not matter what you leave beyond the returned k (hence they are underscores).내 풀이class Solution { public void rotate(int[] nums, int k) { // 풀이법: 배열 크기보다 회전 수가 많다면 배열 크기보다 같거나 작도록 수정한다. (한 바퀴 돌아서 반영되지 않기에) // 회전된 배열에서 인덱스가 원래 배열에서 어떤 인덱스인지 역으로 계산한다. // if added index is larger than array&#39;s size, adjust it to fit it. // example, [0,1,2,3,4], k=3 -&amp;gt; [2,3,4,0,1] 2&#39;s index : 2-&amp;gt;5 (rotate k times)-&amp;gt; 5-5(array&#39;s length) =0 int[] rotated = new int[nums.length]; //if K is larger than array&#39;s length, make it smaller or equal to array&#39;s length if(nums.length &amp;lt; k){ while(nums.length &amp;lt;k){ k -= nums.length; } } // rotated index -&amp;gt; find original index // 회전 후 인덱스 = 원래 인덱스 + 회전수 / (원래 인덱스 +회전수가 배열 크기보다 크다면) 원래 인덱스 + 회전수 - 배열 길이 // 역산하여 회전 후 배열에 들어갈 값의 원래 배열의 인덱스를 알아낸다. int index =0; for(int i=0; i&amp;lt;nums.length; i++){ index= (i-k) &amp;lt;0 ? i-k+nums.length : i-k; rotated[i] = nums[index]; } // copy rotated array to original array // 원래 배열을 재정렬 해야하기에 회전 후 값 저장한 배열을 복사한다. for(int i=0; i&amp;lt;nums.length; i++){ nums[i] = rotated[i]; } }}}}" }, { "title": "java 정규식 정리", "url": "/posts/regex/", "categories": "study", "tags": "IT, java", "date": "2022-03-13 15:05:00 +0900", "snippet": "코테에 나왔던거 복습하기.1. 정규식이란?텍스트 안에서 데이터를 찾을 때, 사용하는 서치 패턴2. java 에서 정규식 사용하기java.util.regex 패키지를 임포트해서 사용할 수 있다.여기 안에는 Pattern (패턴 정의하는데 사용), Matcher (패턴 사용해 검색하는데 사용), PatternSyntaxExeption (syntax 에러에 사용) 클래스가 있다.import java.util.regex.Matcher;import java.util.regex.Pattern;public class Main { public static void main(String[] args) { Pattern pattern = Pattern.compile(&quot;w3schools&quot;, Pattern.CASE_INSENSITIVE); Matcher matcher = pattern.matcher(&quot;Visit W3Schools!&quot;); boolean matchFound = matcher.find(); if(matchFound) { System.out.println(&quot;Match found&quot;); } else { System.out.println(&quot;Match not found&quot;); } }}3. 정규식 표현서치패턴은 다양한 조건을 조합해서 만들 수 있다.연습하면서 배워볼 수 있는 사이트내가 만든 정규식으로 간단히 테스트하는 사이트대표적인 규칙 몇 개만 소개하자면.\\d : 아무 숫자\\D : 아무 숫자 아닌 문자[a-z] : a~z 까지 ,abcd -&amp;gt; regex : [a-d] [이거저거] : 이거저거만포함 &amp;lt;-&amp;gt; [^이거저거]whyme (O) -&amp;gt; regex : [why]me , [^not]me (대신 이러면 callme도 걸림)notme (X){m} : m번 반복111345 -&amp;gt; 1{3} ^abc : abc로 시작하는 것abc$ : abc로 끝나는 것섞어서 쓰고 싶다면 쭉 나열해서 이으면 된다.이렇게 말로만 하면 헷갈리니까 코테에 나왔었던 간단한 전화번호 검증을 예시로 하겠다.4. 간단한 전화번호 검증요구사항허용되는 전화번호의 타입은 1) 010-0000-0000 2) 01000000000 3) +82-10-0000-0000 세가지이다.풀이법 각 케이스 별로 정규식 짜기 010-0000-0000 : 숫자 개수로 판단.+82-010-0000-0000 테스트 통과하지 않도록 앞에 숫자 3개로 시작함 조건 달아줬다. ^(\\d{3})-\\d{4}-\\d{4} 01000000000 \\d{11} +82-10-0000-0000 ^(\\+82\\-)\\d{2}-\\d{4}-\\d{4} | (or) 로 연결 \\d{11}|^(\\+82\\-)\\d{2}-\\d{4}-\\d{4}|^(\\d{3})-\\d{4}-\\d{4} 케이스 테스트케이스 통과 케이스 실패" }, { "title": "프로그래머스 문제 풀이 2 - 기능 개발(Java)", "url": "/posts/function-develop/", "categories": "codingtest", "tags": "IT, JAVA, algorithm", "date": "2022-03-11 11:05:00 +0900", "snippet": "그래도 삶은 계속된당. 오늘 면접본거 복기하기 전에 머리가 어지러워서 한 문제 풀었다. 노좌절 킵고잉문제 내용프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.제한 사항작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다.작업 속도는 100 이하의 자연수입니다.배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.입출력 예progresses speeds return [93, 30, 55] [1, 30, 5] [2, 1][95, 90, 99, 99, 80, 99] [1, 1, 1, 1, 1, 1] [1, 3, 2]스택/큐로 분류되어있지만 굳이 그거 쓸 필요 없다.FIFO 여서 그렇게 해놓은거 같은데 잘 모르겠음.내가 생각한 순서. 1) 작업 완료에 걸리는 일수만이 중요함. 일단 모든 작업에 걸리는 일수를 계산함.2) 앞에서부터 비교하면서 나보다 작은 일수 필요하면 같이 배포, 큰 일수 필요하면 같이 배포 못함. 최대값 찾는 것처럼 비교. input progresses 크기만큼만 한번만 돌면됨.3) 같이 배포 못하는 인덱스 찾으면 여태까지 같이 배포한 갯수 저장, 배포갯수 초기화4) 마지막 배포건은 갯수 저장하는 조건에 안걸리기에 루프 종료후 저장한번 해줌.import java.util.*;class Solution { public int[] solution(int[] progresses, int[] speeds) { int[] answer = {}; //주어진 리턴 타입 int[] neededDays = new int[progresses.length]; //모든 일의 각 필요일수 계산 List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); // 답 저장할 arraylist //-&amp;gt; 배포 몇 번 있을지 모르니 고정 배열 쓸 수 없음. for(int i =0; i&amp;lt;progresses.length; i++){ neededDays[i] = (int)Math.ceil((double)(100-progresses[i])/(double)speeds[i]); //올림으로 계산 } int release =0; //한번에 배포하는 갯수 int index = 0 ; // 비교할 기준 값 for(int i=0; i&amp;lt;progresses.length; i++){ if(neededDays[index]&amp;gt;=neededDays[i]) { ++release; }else{ list.add(release); //값 저장 release=1; //값 초기화 index=i; //기준값 옮기기 } } // 배열의 마지막 값까지 확인한 내용 넣음 (마지막 배포 개수) list.add(release); answer = new int[list.size()]; //정답 포맷에 맞게 변환 for(int i =0 ; i&amp;lt;answer.length; i++){ answer[i] =list.get(i); } return answer; }}" }, { "title": "자료구조 다시보기- tree", "url": "/posts/tree/", "categories": "study", "tags": "IT, web, java, tree", "date": "2022-03-06 17:00:00 +0900", "snippet": "오늘의 TIL - 트리 정리참고-엔지니어 대한민국님 유투브Tree부모 - 자식을 가지는 계층 구조. 각 노드가 하나 이상의 자식 노드를 가진다. 더 이상 자식이 없으면 leaf 라고 부른다. child 가 2개 까지만 붙는 tree 를 binary tree 라고 한다.binary tree &amp;amp; binary search tree (이진 검색 트리)binary tree다른 조건 없이 각 노드에 최대 2개까지의 자식 노드 있음.binary search tree 왼쪽 노드와 그 이하 자식 노드들은 현재 노드보다 작음 오른쪽 노드와 그 이하 자식들은 현재 노드보다 큼. 어떤 값을 찾을때 유용하게 쓸 수 있다.balanced - unbalanced 왼쪽 오른쪽 노드 개수가 너무 차이나지 않으면 balanced 임. balanced 예시 : AVL treecomplete binary tree모든 노드들이 레벨 별로 왼쪽부터 채워져있는 이진 트리full binary tree자식 노드를 가지려면 최대 2개를 다 채워서 가지고, 아니면 가지지 않는 것perfect binary tree모든 노드들이 왼쪽부터 채워져있으며 2개의 자식노드를 다 채운 트리완벽한 피라미드 구조를 띄고 있다 .binary tree 의 탐색법이 그림으로 설명하겠다.Inorderleft -&amp;gt; root -&amp;gt; right 의 순으로 탐색. 루트 노드인 1 부터 탐색한다고 하면, 더이상 왼쪽 아래 자식 노드가 없을 때까지 왼쪽으로 내려간다. 거기서부터 탐색 시작한다.4 -&amp;gt; 2 -&amp;gt; 5 -&amp;gt; 1 -&amp;gt; 3Preorderroot -&amp;gt; left -&amp;gt; right 순위에서부터 루트 (본인) 부터 찾고 왼쪽 노드부터 탐색한다. 1 -&amp;gt; 2 -&amp;gt; 4 -&amp;gt; 5 -&amp;gt; 3Postorderleft -&amp;gt; right -&amp;gt; root 순루트 노드인 1 부터 탐색한다고 하면, 더이상 왼쪽 아래 자식 노드가 없을 때까지 왼쪽으로 내려가되 같은 레벨부터 본다. 4 -&amp;gt; 5 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 1binart tree 탐색법 세가지 java 구현트리 테스트라는 트리 구조를 저장할 클래스를 만들었다.각 노드는 본인의 값과 왼쪽, 오른쪽 아래 자식 노드를 가지고 있다. 재귀 호출로 구현한다. (아래 노드들로 계속 내려갈 수 있도록)public class TreeTest { public class Node{ int data; Node left; Node right; } Node root; public Node getRoot(){ return root; } public void setRoot(Node firstNode){ root = firstNode; } public Node makeNode(int data, Node left, Node right){ Node newNode = new Node(); newNode.data = data; newNode.left = left; newNode.right=right; return newNode; } public void inOrder(Node node){ if(node !=null){ inOrder(node.left); System.out.println(node.data); inOrder(node.right); } } public void preOrder(Node node){ if(node !=null){ System.out.println(node.data); preOrder(node.left); preOrder(node.right); } } public void postOrder(Node node){ if(node !=null){ postOrder(node.left); postOrder(node.right); System.out.println(node.data); } }}테스트 하기 위해서는 자료 구조를 아래 노드부터 채우고 루트 노드에서 탐색법을 검증해본다.public class TestForTree { TreeTest tree; @BeforeEach void init(){ tree =new TreeTest(); TreeTest.Node node4 = tree.makeNode(4,null,null); TreeTest.Node node5 = tree.makeNode(5,null,null); TreeTest.Node node2 = tree.makeNode(2,node4,node5); TreeTest.Node node3 = tree.makeNode(3,null,null); TreeTest.Node root = tree.makeNode(1,node2,node3); tree.setRoot(root); } @Test @DisplayName(&quot;inOrder 4 2 5 1 3&quot;) void inOrderTest(){ tree.inOrder(tree.getRoot()); } @Test @DisplayName(&quot;preOrder 1 2 4 5 3&quot;) void preOrderTest(){ tree.preOrder(tree.getRoot()); } @Test @DisplayName(&quot;postOrder 4 5 2 3 1&quot;) void postOrderTest(){ tree.postOrder(tree.getRoot()); }" }, { "title": "자료구조 다시보기- heap", "url": "/posts/heap/", "categories": "study", "tags": "IT, web, java, tree", "date": "2022-03-06 17:00:00 +0900", "snippet": "오늘의 TIL 트리 정리하는 김에 heap 도 같이 정리참고-엔지니어 대한민국님 유투브heap최대값이나 최소값을 빠르게 찾아내기 위한 완전 이진트리 기반 자료 구조.완전 이진 트리 : 모든 노드가 왼쪽부터 차 있는 이진트리최소 heap작은 값을 위에 오게 해서 루트에 가장 작은 값 있음최대 heap큰 값을 위에 오게함최소 heap 에 노드 삽입하기 완전 이진트리 만족시키기 위해 가장 아래 노드 왼쪽부터 채운다. 부모 노드랑 값을 비교해서 부모가 자기 자신보다 작을때까지 진행한다.최소 heap에 노드 가져오기 맨 위 노드 가져옴 (최소 노드 찾기 쉽게하려고 쓰는 거니까) 빈 자리에 가장 아래 노드로 메꾼다. 자식 노드들 과 비교하면서 아래로 감java api 로 사용하기java.util.PriorityQueue 통해 사용할 수 있다.기본적으로는 minHeap 을 지원해서 아래와 같이 사용 한다.PriorityQueue&amp;lt;Integer&amp;gt; minHeap = new PriorityQueue&amp;lt;&amp;gt;();minHeap.add(5);minHeap.add(2);minHeap.add(3);minHeap.add(1);minHeap.add(4);System.out.println(minHeap.poll());System.out.println(minHeap.poll());System.out.println(minHeap.poll());System.out.println(minHeap.poll());System.out.println(minHeap.poll());//출력 결과: 1 2 3 4 5 MaxHeap 은 이를 반대로 정렬해주면 되는데, PriortyQueue 생성자 중 Comparator 를 인자로 받는게 있다.public PriorityQueue(Comparator&amp;lt;? super E&amp;gt; comparator) { this(DEFAULT_INITIAL_CAPACITY, comparator); }comparator – the comparator that will be used to order this priority queue. If null, the natural ordering of the elements will be used.Throws:여기에 comparator 로 역으로 정렬하도록 하면 된다.여기서 역 정렬 comparator 정리해보자면방법 1Collections.reverseOrder() 방법 2Comparator&amp;lt;Integer&amp;gt; comp = ((a,b)-&amp;gt;b.compareTo(a));방법 1 로 하는게 편하다.//maxheap 예시 PriorityQueue&amp;lt;Integer&amp;gt; maxHeap = new PriorityQueue&amp;lt;&amp;gt;(Collections.reverseOrder()); maxHeap.add(5); maxHeap.add(2); maxHeap.add(3); maxHeap.add(1); maxHeap.add(4); System.out.println(maxHeap.poll()); System.out.println(maxHeap.poll()); System.out.println(maxHeap.poll()); System.out.println(maxHeap.poll()); System.out.println(maxHeap.poll()); //출력 : 5 4 3 2 1" }, { "title": "이펙티브자바 -불필요한 객체 생성 줄이기 &amp; autoboxing", "url": "/posts/autoboxing/", "categories": "study", "tags": "IT, web, java, autoboxing", "date": "2022-03-04 17:00:00 +0900", "snippet": "오늘의 TIL이펙티브 자바를 읽는 중인데, 어렵지만 조금씩 생각해볼 점들은 기록하려고 한다.아이템 6) 불필요한 객체 생성을 피해라.OOP의 장점인 재사용성을 생각하면 당연한 말이지만, 코드를 짤 때 은근히 간과할 수 있는 부분이다.어떤 자바 제공 유틸 클래스를 사용할 때, 단순히 로직만 생각해서 메소드를 마구 호출하곤 했다. 메서드 내부에서 어떤 객체를 생성하고 동작하는지를 유심히 살펴보지 못했다.특히나 책에 실린 예제인 String.matches 보고 반성하게 됐다. String.matches 메서드 내부에서는 정규식용 Pattern 인스턴스를 생성하는데, 이는 한번 사용하고 바로 가비지 컬렉션 대상이 된다. 이를 개선하려면 클래스 초기화 과정에서 Pattern 인스턴스를 필요한 정규식으로 초기화 하고 메서드 호출시 재사용하는게 낫다.autoboxing이렇게 나도 모르는 사이에 인스턴스를 생성하는 예시 중 하나가 오토박싱이다.autoboxing 이란?기본 데이터 타입을 wraaper 클래스를 통해 객체로 변환하는 것정의부터가 객체로 만들어 사용하려고 하는것이기 때문에 그 사용 이유에 맞게 써야한다. 남발해서는 안됨.Integer a = 100; (실제 선언)-&amp;gt; Interger a = new Integer(100); (오토박싱이 동작하는 방식)autoboxing 사용하는 이유참고-Why do we use autoboxing and unboxing in Java?Generics 사용하기 위함. primitive data 타입은 길이가 정해져있지 않는 반면에 Object, String 같은 타입은 크기가 정해져있다. 즉 상호호환되어 사용 가능하다. (String 을 Object 로 쓴다던지.) Generics 사용할 땐 JVM 의 혼동을 줄이고자 모두 Object 로 생성한다. 따라서 Object로 호환될 수 없는 타입은 들어갈 수 없다.이를 type erasure 라고 부른다. 참고 List&amp;lt;T&amp;gt; -&amp;gt; List&amp;lt;Integer&amp;gt; : 가능 List&amp;lt;int&amp;gt; : 불가능 " }, { "title": "웹 보안에 대하여 2 - JWT 와 구현 방법", "url": "/posts/web-security-02/", "categories": "study", "tags": "IT, web, git", "date": "2022-03-03 17:00:00 +0900", "snippet": "팀플하면서 JWT 공부하고 구현해본 내용 올려야겠다.JWT (Json Web Token) Json 객체를 통해서 관리되는 토큰 방식. 헤더, 페이로드, 서명으로 구성되어 있다. http header 에 담아서 서로 통신. 클라이언트에 저장하기에 서버에서 클라이언트의 토큰 조작할 수는 없다.헤더 : 토큰의 타입과 해싱 알고리즘 정보 들어있다. 나중에 토큰 검증할때 서명 부분에 사용된다.페이로드 : 토큰에 담을 정보를 말하며, 이 때 정보 하나씩을 클레임 이라고 한다. 공개 클레임: 충돌을 방지하기 위한 정보로 URI 형식으로 지음 등록된 클레임: 토큰에 대한 정보를 담기 위해 이미 정해진 정보들. Ex) 토큰 발급자, 만료 시간 등 . 고정 정보 공개 클레임: 충돌을 방지하기 위한 정보로 URI 형식으로 지음 비공개 클레임: 클라이언트- 서버 간 협의를 위해 만든 클레임. (유저 이름 이런거) 서명 : 헤더의 인코딩 값과 페이로드의 인코딩 값을 다시 해시해서 만든다.이렇게 만든 데이터를 . 으로 조합해 다시 base64 인코딩 시켜서 보낸다.JJWT :자바에서 JWT 토큰 구현하는 라이브러리 중 하나 (https://github.com/jwtk/jjwt#jws). JWT 처리를 위한 builder, parser 제공한다. Dependency 추가해서 사용 시작함. 헤더: 토큰의 타입, 해시 알고리즘 방식 세팅할 수 있고, 세팅 안하면 토큰 타입은 JWT, 해시 알고리즘은 sha256으로 세팅된다. (위의 예시) 페이로드 : 기본 정보인 발급자, 발급시간, 만료시간 등은 set 함수로 개별 구현되어있다. 커스텀 내용들은 map&amp;lt;String, String &amp;gt; 으로 만든 후 setClaims ()로 넣는다. 서명 : signWith() 메소드에 각자 secret key 로 사용할 키를 넣는다. 기본 알고리즘은 sha256 이며 , .signWith(key,SignatureAlgorithm.HS512) 같이 알고리즘 변경 가능하다.소스 구현전체 소스는 여기 에서 볼 수 있다. 구현시에는 jjwt 라이브러리 레포에서 보고 따라하면 사실 너무 쉽게 완성되긴하는데, 버전마다 달라지는 내용이 많아서 제대로 확인후에 구현해야한다. 나는 버전 0.10.7 사용하였다.//1. 서명에 사용할 키 생성 (실개발때는 프로퍼티로 관리) private String keyString = &quot;Mauristinciduntpurustortoretfusceaaaabbbbeeeccc&quot;; //랜덤 문장 생성기에서 랜덤 생성 public String createToken(String userName, String role) { //2. 만료시간 설정 Date now = new Date(); Date expiration = new Date(now.getTime() + Duration.ofDays(1).toMillis()); // 만료기간 1일 //3. JWT 생성 Claims claims = Jwts.claims().setSubject(userName); // JWT payload 에 저장되는 정보단위 claims.put(&quot;roles&quot;, role); // role 받아서 권한 설정해준다. 나중에는 이 권한 파싱해서 권한제어에 사용 . (admin -&amp;gt; 관리자 권한, user -&amp;gt; 일반사용자) String jws = Jwts.builder().setSubject(userName) //토큰 발급 받은 사람 특정 .setIssuer(&quot;testProduct&quot;) //발급자 .setIssuedAt(now).setExpiration(expiration) //발급시간, 만료시간 .claim(&quot;roles&quot;,role) .setSubject(userName) .signWith(SignatureAlgorithm.HS256,keyString) .compact(); return jws; } public Jws&amp;lt;Claims&amp;gt; isValid(String jws){ //userName 뽑아내어 리턴 -&amp;gt; 추후에는 롤이나 다른 중요 값 뽑아서 검증해도 됨. String userName =null; Jws&amp;lt;Claims&amp;gt; parsedJwt =null; try { parsedJwt = Jwts.parser().setSigningKey(keyString).parseClaimsJws(jws); }catch (SignatureException e){ // 서명 인증 안되는 경우 throw new SignatureException(&quot;Invalid token&quot;); }catch (ExpiredJwtException e){ //만료된 경우 throw new ExpiredJwtException(parsedJwt.getHeader(),parsedJwt.getBody(),&quot;Expired!&quot;); } return parsedJwt; } // jwt 파싱한 내용 확인 public String getInfoByToken(Jws&amp;lt;Claims&amp;gt; parsedJwt) throws Exception { String jwtBody =parsedJwt.getBody().toString(); if (jwtBody == null){ throw new Exception(&quot;jwtBody is empty&quot;); } return jwtBody; }1편에서 말했듯이 토큰은 헤더에 담아서 전달되기에 아래처럼 클라이언트- 서버간 전달할 수 있다.//토큰 생성해 클라이언트에 보낼때 response.setHeader(&quot;X-AUTH-TOKEN&quot;, token); // response header 세팅Cookie cookie = new Cookie(&quot;accesstoken&quot;, token); // 쿠키에 저장해 다음 요청때 쓸 수 있도록 함.cookie.setPath(&quot;/&quot;);cookie.setHttpOnly(true);cookie.setSecure(true);response.addCookie(cookie);// 클라이언트에서 토큰 받았을때public ResponseEntity&amp;lt;?&amp;gt; loginActionWithToken( @RequestHeader Map&amp;lt;String, String&amp;gt; data) { String token = null; //header 에 accesstoken이란 값이 있다면 파싱 if(data.get(&quot;accesstoken&quot;) !=null) { token =jwtcon.validToken(data.get(&quot;accesstoken&quot;)); } return new ResponseEntity&amp;lt;&amp;gt;(token, HttpStatus.OK); }" }, { "title": "클래스 변수, 인스턴스 변수, 지역변수 그리고 JVM 메모리 구조", "url": "/posts/variable/", "categories": "study", "tags": "IT, java", "date": "2022-03-01 09:05:00 +0900", "snippet": "java 변수 종류와 이게 JVM 메모리 상에 어떻게 다르게 저장되는지 정리 . 기본 공부하려고 자바의 정석 조금씩 읽다가 정리한당.1. 클래스 변수, 인스턴스변수, 지역 변수이 셋을 구분 짓는건 변수 선언된 위치이다. 클래스 변수: 클래스 영역에서 선언되었으며 앞에 static 붙어있음. 모든 인스턴스 (클래스를 통해 객체화된 인스턴스들)이 공통된 변수를 공유하게 된다. 클래스의 모든 인스턴스들이 공통된 값을 가져야하는 경우 이를 사용하면 된다. 클래스가 메모리에 올라갈 때 메서드 영역에 생성된다. 인스턴스 변수: 클래스 영역에서 선언됨. 인스턴스를 생성할 때 만들어진다. 즉 사용하려면 먼저 인스턴스를 생성해야한다.인스턴스마다 각자 고유한 값을 가져야한다면 인스턴스 변수로 만든다. 지역 변수: 메서드 내에 선언되어 메서드 내에서만 사용가능하며 종료되면 소멸되어 사용 불가능하다.2. JVM 메모리 구조참고-기본기를 쌓는 정아마추어 코딩블로그메소드 영역JVM 이 클래스 파일 읽어 클래스에 대한 정보 저장하는 곳이다.힙 영역new 키워드로 생성된 인스턴스가 생성되는 장소. 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거한다.스택메서드가 호출되면 이를 위한 메모리 할당된다. 이 메서드를 실행하는데 필요한 지역 변수등 임시 데이터를 저장하는데 쓰인다. 메서드가 종료되면 공간이 반환되어 비어진다.이름에서 알 수 있듯이 메모리 공간은 메서드 호출 순대로 차곡 차곡 할당되어 첫번째 메소드가 안 끝낫는데 두번째 메소드가 호출된다면 두번째 메소드부터 수행된다. (LIFO)메소드 별로 저장공간은 구분된다. 잘못된 재귀 호출로 무한 루프에 빠지면 스택이 계속 쌓여서 스택오버플로우 에러가 난다.PC Register (PC 레지스터)쓰레드 생성될 때마다 생성됨. 현제 쓰레드가 실행되는 부분의 주소 저장한다.3. 클래스 메소드에서 인스턴스 변수 호출 못하는 이유클래스 읽어올 때부터 메소드 영역에 클래스 변수, 메소드는 존재하지만 인스턴스 변수는 아직 인스턴스 생성 안되어 존재하지 않을 수 있음.따라서 클래스 멤버가 인스턴스 멤버 참조 또는 호출하고자 하는 경우는 인스턴스 생성해야한다." }, { "title": "spring framework - @Controller @RestController 차이점", "url": "/posts/controller-annotation/", "categories": "spring", "tags": "IT, java, spring", "date": "2022-02-28 18:05:00 +0900", "snippet": "개인 프로젝트를 만들다가 정리하는 spring annotation 중 @Controller0. 어노테이션 사용하는 이유스프릥 프레임워크의 특징 중 하나인 IoC 를 하기 위해선 프레임워크가 알아서 인스턴스를 생성하고 적재적소에 사용할 수 있어야한다.BeanFactory, ApplicationContext 인터페이스가 이런 일 하는데, 이 인터페이스들이 어떤게 bean 으로 만들어야할 것들인지 알기 위해 사용한다. 이전에는 xml 사용한 주입 등이 있었는데 이 구조는 이 블로그 참고.1. @Controller 어노테이션전통적으로 Spring MVC 에서 사용된 어노테이션. @Component 라는 스프링 빈 등록 어노테이션을 구체화 한 용도로 해당 클래스가 컨트롤러 역할을 함을 알린다. Spring MVC는 서블릿 위에 구축된 프레임워크로 요청이 들어오면 DispatcherServlet에 매핑해 맞는 핸들러를 찾아 호출한다.(* 핸들러란, @Controller 클래스와 함께 사용되는 request mapping 메소드들 )주 목적이 view 를 리턴하는게 목적이며, Json 형태의 리턴을 하기 위해서는 핸들러에 @ResponseBody 어노테이션과 함께 사용한다.2. @RestController 어노테이션@Controller + @ResponseBody 역할이다. Spring 4 부터 제공하며 핸들러인 @RequestMapping 메서드가 기본적으로 @ResponseBody 의미를 가정해 view 대신 데이터를 리턴한다." }, { "title": "자료구조 다시보기- queue", "url": "/posts/queue/", "categories": "study", "tags": "IT, java", "date": "2022-02-27 09:07:00 +0900", "snippet": "오늘의 TIL 힘차게 나와주세요 ~~~~~~!!!참고 1 - [자료구조 알고리즘] Queue 구현하기 in Java1. queue스택과 다르게 queue 는 FIFO 구조 이다. 사람들이 줄 서 있는 것과 같다. 늦게 온 사람은 맨 뒤에 서고, 맨 앞에 미리 서있던 사람부터 빠진다.2. queue 자료구조를 사용하는 예시 하나의 자원을 공유하는 경우: 프린터 대기 리스트나 CPU Mp3 같은 어플리케이션에서 버퍼로 쓰인다.3. java 로 구현.스택은 입구와 출구가 같은 꼴이었기에 top 만 기억하면 됐는데, 큐는 서로 다르기에 맨 앞 과 맨 뒤 자료를 기억하는 포인터가 필요하다.package example;import java.util.NoSuchElementException;public class QueueTest&amp;lt;T&amp;gt; { class Node&amp;lt;T&amp;gt; { private T data; private Node&amp;lt;T&amp;gt; nextNode; public Node(T data){ this.data =data; } } private Node&amp;lt;T&amp;gt; first; private Node&amp;lt;T&amp;gt; last; //앞부터빠지니까 first 노드를 바꾸기 위해모든 노드들이 다음 노드를 알아야함. -&amp;gt; 마지막에 들어오는 노드 위해 last 노드 갱신해갈 필요 있음. public void add(T data) { Node&amp;lt;T&amp;gt; newNode = new Node&amp;lt;T&amp;gt;(data); if (first ==null) { first = newNode; //first 비워져있으면 거기 채움. } if(last !=null){ last.nextNode = newNode; } last = newNode; } public T remove(){ if(first==null){ throw new NoSuchElementException(); } T value =first.data; first =first.nextNode; // 여기를 위해 lastnode 알아야함 return value; } public T peek(){ if(first==null){ throw new NoSuchElementException(); } return first.data; } public boolean isEmpty(){ return first ==null ? true: false; }} @Test void queueTest(){ QueueTest&amp;lt;Integer&amp;gt; queue = new QueueTest&amp;lt;Integer&amp;gt;(); queue.add(3); queue.add(4); queue.add(5); queue.add(6); queue.remove(); assertThat(queue.peek()).isEqualTo(4); } @Test void isEmptyTest(){ QueueTest&amp;lt;Integer&amp;gt; queue = new QueueTest&amp;lt;Integer&amp;gt;(); assertThat(queue.isEmpty()).isTrue(); queue.add(3); queue.remove(); queue.add(4); queue.add(5); assertThat(queue.isEmpty()).isFalse(); queue.remove(); queue.remove(); assertThat(queue.isEmpty()).isTrue(); }" }, { "title": "자료구조 다시보기- stack", "url": "/posts/stack/", "categories": "study", "tags": "IT, java", "date": "2022-02-27 09:05:00 +0900", "snippet": "오늘의 TIL 힘차게 나와주세요 ~~~~~~!!!참고 1 - javatpoint What is a Stack? 참고 2 - [자료구조 알고리즘] Stack 구현하기 in Java1. stack스택은 LIFO (Last In First Out)을 따르는 자료구조이다.한 방향으로만 흘러가가기에 queue 와는 다르게 가장 위에 있는 element 만 가르키는 포인터 하나만 있다.현실세계에서 책상에 책을 쌓아두면 가장 위에 쌓은 책부터 치울 수 있는 것과 같다.2. stack 자료구조를 사용하는 예시 Balancing of symbols : 클래스 선언의 시작과 끝에는 {} 가 들어가야한다. 이렇게 선언의 시작과 끝을 알때도 스택을 사용한다. { 로 시작했다면 탑에 }가 들어올때까지가 한 클래스다. 메모리 관리 : 스택 메모리 블럭에 함수가 생성될 때 차곡차곡 데이터 저장했다가 함수 종료되면 메모리 정리한다. string 을 거꾸로 만들고 싶을때: stack 에 문자를 하나씩 넣고 pop 하면 뒤에서부터 뺄 수 있기에 거꾸로 배열할 수 있다.3. java 로 구현import java.util.EmptyStackException;public class StackTest&amp;lt;T&amp;gt; { class Node&amp;lt;T&amp;gt;{ private T data; private Node&amp;lt;T&amp;gt; next; public Node(T data){ this.data = data; } } private Node&amp;lt;T&amp;gt; top; public T pop(){ if(isEmpty(){ throw new EmptyStackException(); } T value = top.data; //top 의 데이터 저장 top = top.next; //top을 없애고 그 다음 노드가 탑이 됨 return value; // 값 반환 } public T peek(){ if(top == null){ throw new EmptyStackException(); } return top.data; } public void push(T input){ Node&amp;lt;T&amp;gt; newNode =new Node&amp;lt;&amp;gt;(input); if(!isEmpty()){ newNode.next = top; // 다음 값에 현재 탑 저장 } top = newNode; //탑 바꾸기 } public boolean isEmpty(){ return top == null ? true : false; }}유닛 테스트 @Test void stackTest(){ StackTest&amp;lt;Integer&amp;gt; stack = new StackTest&amp;lt;Integer&amp;gt;(); stack.push(2); stack.push(3); stack.push(4); stack.push(5); stack.pop(); assertThat(4).isEqualTo(stack.peek()); } @Test void isEmptyTest(){ StackTest&amp;lt;Integer&amp;gt; stack = new StackTest&amp;lt;Integer&amp;gt;(); assertThat(true).isEqualTo(stack.isEmpty()); stack.push(2); stack.push(3); assertThat(false).isEqualTo(stack.isEmpty()); stack.pop(); stack.pop(); assertThat(true).isEqualTo(stack.isEmpty()); }" }, { "title": "java string builder, string buffer 그리고 string 이야기", "url": "/posts/stringclass/", "categories": "study", "tags": "IT, java", "date": "2022-02-25 15:05:00 +0900", "snippet": "오늘의 TILString 에 대해서 조금 정리하고자 한다.1. String 클래스imuutable 한 클래스 이다. (변경 불가능한 클래스)인스턴스 생성시 인스턴스 변수에 문자형 배열 참조변수를 정의한다.즉 String 정의 시마다 문자열 배열이 생성되고 그 주소를 참조하는 구조이다.문자열은 읽어 올 수만 있고, 변경할 수 없다.문자열을 더해야하는 경우에 + 할 때마다 새로운 문자열 담긴 인스턴스 생성되기에 메모리 공간을 많이 차지하게 된다.이런 경우는 Stringbuffer 나 Stringbuilder 사용하는 것이 좋다.문자열을 만들시에는 리터럴(내용)을 정의하거나 String 클래스의 생성자를 이용하는 방법 두가지 있다.같은 리터럴은 한번만 정의된다. (어차피 변경 불가능하니 참조하면 되니까)생성자로 만들시에는 문자열 배열 인스턴스가 각각 생성된다.2. == 과 .equals 차이즉 우리가 String 변수 정의한 건 문자열 배열 위치 정보를 담는다. == 으로 String 을 비교하면 주소값 비교이기에 오류가 생길 수 있다. .equals 해야 값 비교 가능하다. @Test void stringEqualsTest(){ String s =&quot;abc&quot;; String s2 =&quot;abc&quot;; String s3 =new String(&quot;abc&quot;); String s4 = new String(&quot;abc&quot;); assertThat(s==s2).isTrue(); assertThat(s3==s4).isFalse(); // 생성자로 만들어서 인스턴스 각 생성-&amp;gt; 주소 다름 assertThat(s3.equals(s4)).isTrue();// 리터럴은 똑같음 }3. 문자열 결합하는 방법1) 문자열 사이에 구분자 넣어서 결헙 java.util.Stringjoiner 클래스 사용. @Test void stringJoinTest(){ StringJoiner sj = new StringJoiner(&quot;-&quot;,&quot;[&quot;,&quot;]&quot;); // 구분자 - , prefix [, suffix ] String[] arr = new String[]{&quot;one&quot;,&quot;two&quot;,&quot;three&quot;}; String actual = &quot;[one-two-three]&quot;; for(String s: arr){ sj.add(s); } assertThat(actual).isEqualTo(sj.toString()); }4. StringBuffer, StringBuildernew 연산으로 클래스를 한 번만 만들기에 Mutable하다.미리 배열 공간 만들어놓고 바로 값을 복사한다. 배열 공간 선언하는 횟수가 현저히 줄어든다.공간 부족할 경우만 공간 늘리고 값을 복사한다.차이StringBuffer 는 동기화되어 느리지만 멀티쓰레드 환경에서 thread-safe 하다.StringBuilder 는 비동기화여서 빠르다.비교equals 는 오버라이딩되어 있지않다. (내부 값 비교하고 싶으면 toString 후 equals)## StringBuider 구현 유투버 엔지니어대한민국님 영상 을 보고 따라 만들어봤다. 역시 코드로 보니 이해가 편해 굿public class BuilderTest { char[] values; //값 저장할 문자열 배열 int index; //값 어디까지 차있는지 체크에 사용 int size; //배열 사이즈 public BuilderTest(int givenSize){ values =new char[givenSize]; index =0; size =givenSize; } public void append(String s){ if (s == null){ s = &quot;null&quot;; } capicity(s.length()); //배열 크기 검사 for(int i =0; i &amp;lt; s.length() ; i++){ values[index] = s.charAt(i); //배열에 값 넣기 ++index; } } // 배열 공간 확인 후 부족하면 두배로 늘려줌 public void capicity(int stringSize){ if(index+stringSize &amp;gt; size){ size = (size + stringSize)*2 ; char[] temp = new char[size]; for(int i=0; i&amp;lt;values.length; i++){ temp[i] = values[i]; // 기존 값 복사 } values = temp; // 늘린 배열로 교체 } } public String toString(){ return new String(values, 0, index); } }내가 셀프로 만든것과 StringBuilder 클래스 결과를 비교하는 테스트//unit test @Test void builderTest(){ BuilderTest builder = new BuilderTest(1); builder.append(&quot;hi&quot;); builder.append(&quot;hello&quot;); builder.append(&quot;good&quot;); StringBuilder sb =new StringBuilder(); sb.append(&quot;hi&quot;); sb.append(&quot;hello&quot;); sb.append(&quot;good&quot;); assertThat(builder.toString()).isEqualTo(sb.toString()); }" }, { "title": "java 소숫점 올림, 반올림 하는 방법 그리고 데이터형 기본 챙기기", "url": "/posts/math-ceil/", "categories": "study", "tags": "IT, java", "date": "2022-02-19 15:05:00 +0900", "snippet": "java 에서 소숫점 올림, 반올림 시에 사용하는 Math 클래스 내 메소드들.기본적이지만 사용시 헷갈리던게 있어서 포스팅한다.1. java 에서 소숫점 반올림, 올림 하는 법 반올림 : public static int round(float a) 를 사용함. 사용법 : Math.round(float 넣음) // get two float numbers float x = 1654.9874f; float y = -9765.134f; // find the closest int for these floats System.out.println(&quot;Math.round(&quot; + x + &quot;)=&quot; + Math.round(x)); // 1655 System.out.println(&quot;Math.round(&quot; + y + &quot;)=&quot; + Math.round(y)); // -9765 올림 : public static double ceil(double a)사용법 : Math.ceil(double 넣음) // get two double numbers double x = 125.9; double y = 0.4873; // call ceal for these these numbers System.out.println(&quot;Math.ceil(&quot; + x + &quot;)=&quot; + Math.ceil(x)); //126 System.out.println(&quot;Math.ceil(&quot; + y + &quot;)=&quot; + Math.ceil(y)); // 1.0 System.out.println(&quot;Math.ceil(-0.65)=&quot; + Math.ceil(-0.65)); // -0.0 2. 사소하지만 주의할 점사용하다보면 ceil 했는데 왜 올림이 안되고 내림이 되는거지? 할 때가 있다. 변수 정의하다보면 데이터 타입을 int 로 주었던 걸 이용해서 정제해야할 경우가 있다. 이 경우 헷갈리는 문제가 된다. int a = 3; int b = 16; int c = (int) Math.ceil(b/a); // expected : 6 reality : 5 이 경우는 ceil 안의 b 와 a 가 int 이기때문에 생기는 문제이다. int끼리 연산은 int 가 되기 때문,,, 당연하고 기초인데 하다보면 꼬이게 된다.이래서 기초가 중요한 것 !!# 3. 자바 기본 데이터형 참고" }, { "title": "java class 생성자 말고 정적 팩토리 메소드 사용하기 (이펙티브 자바)", "url": "/posts/class-constructor/", "categories": "study", "tags": "IT, java", "date": "2022-02-18 15:05:00 +0900", "snippet": "이펙티브 자바를 읽고 있는데, 여기서 말하는 정적 팩토리 메소드 사용하기를 java exercism 문제 풀다가 활용했다. 반갑기도 하고 신기하기도 해서 정리하는 생성자 이야기 !!1. 생성자란?인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드이다. (인스턴스란 클래스로부터 만들어진 객체이다.) 사용자가 정의하지 않는다면 클래스명과 같은 이름으로 아무 매개변수 없는 기본 생성자가 만들어져 내부 동작한다.사용자가 원하는 로직대로 초기화 하고 싶다면 클래스명과 같은 이름으로 생성자 만들면된다.2. 정적 팩토리 메서드생성자 말고 클래스의 인스턴스 반환하는 단순한 정적 메서드.장점 이름을 가질 수 있다. (클래스 명과 동일할 필요 없음.) 호출될 때마다 인스턴스 만들지 않아도 된다. (싱글턴으로 활용할 수 있음) 반환 타입의 하위 타입 반환 가능하다. static method를 작성하는 시점에 반환할 객체의 클래스가 존재하지 않아도 된다. (실행시 어떤 클래스 사용할지 정해져도 된다.)단점 상속을 위해서는 정적 메소드만 있으면 public, protected 필요하기에 정적 팩토리 메서드만을 가진 클래스 상속할 수 없다. 프로그래머가 찾기 어렵다. -&amp;gt; 메서드 명명 규칙을 따라서 인스턴스화 하기 쉽도록 해야한다.(ex. ~~~.of() 이런식으로 해야함. )예시 - from(매개변수 1개) , of(매개변수 여러개), getInstance(), newInstance(늘 새로운 인스턴스임)3. 활용 예시Exercism - java 문제 중에 Elons toy car 가 있다. class 생성 연습하는 문젠데 여기서 정적 팩토리 메서드로 사용하였다.문제 조건 buy() 로 차 구매해서 drive 호출시마다 거리는 20 미터 증가, 배터리는 1퍼센트씩 깎이도록 하여라.거리가 2000 미터 이상이면 더 이상 달리지 못하도록 하기.여기서 그냥 생성자 써도 되지만 정적 팩토리 메서드를 사용하였다.스켈레톤 소스에서 그렇게 하도록 유도되어있는데, 이는 정적 팩토리의 장점인 이름을 가질 수 있다는 점을 이용해 직관적으로 buy 라는 행위의 의미를 전달하기 위함으로 인거 같다.나는 배운걸 바로 써볼 수 있어서 즐거웠다. ㅎㅎ 나이스 타이밍 ㅎㅎ 다른 문제에도 적용해봐야징 ㅎㅎ그리고 역시나 단점으로 되어있는 프로그래머가 알아차리기 어렵다도 겪었다…exercism 에서 제공하는 테스트에서조차, 스켈레톤을 정적 팩토리 메서드 쓰도록 유도했음에도 불구하고 인스턴스화를 기본 생성자를 불러서 테스트 코드를 짰더라 !! 내가 테스트코드대로 돌리려면 굳이 기본 생성자를 만들어서 거기서 변수 초기화 하고 정적 팩토리 메서드에서는 생성자 호출해 인스턴스 반환해주는 일만 하면 된다.그렇게 짤 수 도 있지만 굳이 그래야하나 싶기는 하다.그래서 짠 내 코드 !!public class ElonsToyCar { private int distance; private int battery; // 싱글톤으로 할 필요 없어서 정적 팩토리 메서드 호출시마다 새 인스턴스 생성해 반환하도록 하였다. public static ElonsToyCar buy() { ElonsToyCar car = new ElonsToyCar(); car.battery=100; car.distance =0; return car; } public String distanceDisplay() { return String.format(&quot;Driven %d meters&quot;,distance); } public String batteryDisplay() { if(battery==0){ return &quot;Battery empty&quot;; } return String.format(&quot;Battery at %d%%&quot;,battery); } public void drive() { if(distance &amp;lt; 2000){ distance +=20; --battery; } }}" }, { "title": "react 시작하기 그리고 싱글페이지 어플리케이션", "url": "/posts/start-react-frontend/", "categories": "react", "tags": "IT, react", "date": "2022-02-17 15:05:00 +0900", "snippet": "팀 프로젝트에서 프론트엔드를 리액트로 구성하고자 해서 로컬에서 띄워보는 연습하고 있다.참고한 내용은 https://sundries-in-myidea.tistory.com/71 입니다.1. 리액트란?자바스크립트의 라이브러리 중 하나로 프론트엔드 라이브러리이다. 이는 싱글페이지 어플리케이션을 개발하는데 유용하여 인기인데,,, 그래서 싱글페이지 어플리케이션이 뭐요…?2. 싱글페이지 어플리케이션 (SPA)정적인 리소스는 한번에 읽어와 렌더링 해놓고, 사용자 요청에 따라서 필요한 부분만 동적으로 다시 부분 렌더링 하는 방식의 웹 어플리케이션을 말한다.기존 방식에선 동적인 리소스 필요할 때마다 전체 페이지가 리로드 되었는데, 이를 줄여 트래픽 효율적이다.하지만 처음 구동시 정적 리소스를 모두 다운받기에 구동이 느리다는 단점이 있다.참고-싱글 페이지 애플리케이션(Single Page Application, SPA) 개념참고2- [React] 프론트 엔드와 백 엔드 분리 시 동작 원리 (vs 풀 스택)3. 설치 및 실행 node, npm 설치 프로젝트 폴더 만들고 싶은 위치에서 npx create-react-app 프로젝트명 (ex: npx create-react-app reactex) 이때 프로젝트명 대문자 없이 소문자로 기입 프로젝트 폴더에서 npm start 로 서버 기동 -&amp;gt; 기본 포트 3000 으로 서버 기동됨.4. 백엔드(API) 와의 통신 !다른 서버로 포트 다르게 뜨다보니, 그냥 localhost:포트번호 해서 호출하면 CORS 오류가 난다.CORS 오류란? 다른 origin 에서 오는 자원을 차단하는 것으로, 여기서는 본인의 origin 은 localhost:3000인데, 포트가 다른 백엔드 서버를 호출해 거기서 온 응답을 사용하려고 하니 발생한다. 따라서 package.json에 프록시 처리를 해주어야한다.&quot;proxy&quot;: &quot;http://localhost:8080&quot;, 이런식으로 !!fetch 해서 자세히 쓰는 동작은 내가 리액트를 잘 몰라서 아직 다 이해한게 아니라 여기에 붙이진 않겠습니당 !!" }, { "title": "프로그래머스 문제 풀이 1 - 완주하지 못한 선수 (Java)", "url": "/posts/unfinished-runner/", "categories": "codingtest", "tags": "IT, JAVA, algorithm, hashmap", "date": "2022-02-15 15:05:00 +0900", "snippet": "코테 문제 풀이 한 것도 하나씩 올려보고자 합니당. 스스로 복기할 겸 + 검색해 들어오신 분들에게 조금이라도 도움되었으면 합니다.문제 내용수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.제한사항마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.completion의 길이는 participant의 길이보다 1 작습니다.참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.참가자 중에는 동명이인이 있을 수 있습니다.입출력 예participant completion return[“leo”, “kiki”, “eden”] [“eden”, “kiki”] “leo”[“marina”, “josipa”, “nikola”, “vinko”, “filipa”] [“josipa”, “filipa”, “marina”, “nikola”] “vinko”[“mislav”, “stanko”, “mislav”, “ana”] [“stanko”, “ana”, “mislav”] “mislav” public static String solution(String[] participant, String[] completion) { String answer = &quot;&quot;; /* 풀이 과정 지원자 - 완주자를 비교하여 중복된 값을 제거하고 지원자에 남은 값이 완주 못한 자입니다. 중복된 키 값을 허용하지 않는 hashmap의 특성을 사용해 풀었습니다. 1) 지원자를 모두 hashmap 에 이름 키 값으로 넣음. 이때 value 는 이름이 들어간 횟수로 하였습니다. (중복 이름 가능성때문에) 2) 완주자 리스트 돌면서 지원자 hashmap에 검색되면 삭제함. 중복 이름 때문에 value 가 2 이상(두 명 리스트에 있음) 이라면 value 값을 줄여 카운트 처리만 하고 삭제하지 않았습니다. 3) 완주자 돌면서 삭제하고 남은 값 하나가 완주 못한자이기에 키 값 뽑아서 answer 에 넣도록 함. */ //value 로 쓸 변수, hashmap 초기화 int index = 0; HashMap&amp;lt;String,Integer&amp;gt; answerMap=new HashMap&amp;lt;&amp;gt;(); // 지원자 돌면서 이미 있다면 value +1, 없다면 1 로 맵에 넣기 (1) for(String name : participant){ if(answerMap.containsKey(name)){ index = answerMap.get(name); answerMap.put(name, ++index); }else{ answerMap.put(name, 1); } } // 완주자 돌면서 키 있고, 값 1 이라면 바로 삭제, 값 2 이상이면 값 - 1 로 교체 for(String completedName : completion){ if(answerMap.containsKey(completedName)){ index = answerMap.get(completedName) ; if(index == 1 ){ answerMap.remove(completedName); }else if(index &amp;gt; 1){ answerMap.put(completedName,--index); } }else{ // key 값 업다면 바로 이름 넣기 answer = completedName; } } if(answer.equals(&quot;&quot;)){ //키 없는 값 있어서 answer 정해지지 않았다면 List&amp;lt;String&amp;gt; list =new ArrayList&amp;lt;&amp;gt;(answerMap.keySet()); answer = list.get(0); } return answer;" }, { "title": "JUnit 으로 단위 테스트 하기.", "url": "/posts/JUnit-test/", "categories": "study", "tags": "IT, JAVA, Juit", "date": "2022-02-11 18:05:00 +0900", "snippet": "오늘의 TIL !! Junit 에 대해서 간단히 정리하고자 한다.넥스트 스텝의 자바 플레이그라운드 with TDD, 클린코드 강의를 참고 하였습니다.0. JUit 이 나오게 된 이유메인 메소드의 용도 중 하나로 테스트 기능이 있다. 처음 자바를 배우면 sysout 으로 열심히 찍어가면서 테스트하던 그 용도이다.하지만 메인 메소드에 테스트 코드를 쓰게 되면 아래와 같은 단점들이 있다.(강의 중 여러 단점이 있는데 내가 와닿은 단점들) 테스트 결과를 사람이 수동으로 확인해야함. 메소드 이름을 통해 어떤 부분을 테스트 하려는지 드러내기 어려움. 메인 메소드 하나에서 여러개의 기능을 테스트 하므로 복잡도가 증가함.이걸 피하고자 유닛 테스트가 필요해졌고, JUnit 이 나오게 됐다.유닛테스트유닛 테스트는 화이트 박스 테스팅으로 테스터는 어떻게 동작할지를 고르고 인풋을 정하고 예측한 결과대로 나오는지 확인한다. unit 이라는 단어에서 볼 수 있듯이 하나의 메소드나 클래스처럼 스코프를 한정시켜 그 부분을 테스트한다.출처1. JUnit 이란?Java 의 유닛 테스트 프레임워크이다. JUnit 5 가 가장 최신 버전이며, platform, Jupiter, Vintage 세 가지 섹션으로 이루어져있다.Platform : JVM 위에서 테스트 프레임워크 동작하는데 기초를 제공한다. Jupiter : 테스트 작성하는데 필요한 API 모델의 모음이다.Vintage : 이전 버전을 기반으로 짜놓은 코드를 돌아가기 위한 도움을 준다.Junit 5 는 이전 버전으로 짜여진 코드여도 컴파일은 정상으로 되지만 공식적으로 java 8부터 지원한다.2. 자주 쓰이는 어노테이션들@Test이 메소드가 테스트 메소드라는 걸 알려준다.## @BeforeEach , @AfterEach 각각의 @Test 실행 전이나 후에 꼭 실행된다. Junit4 에서의 @Before, @After 와 같은 역할이다.## @PaParameterizedTest 테스트에 파라미터를 넣고 싶을 때 쓰인다. 선언 후 @ValueSource 로 파라미터 넣는다. 파라미터를 여러 케이스로 넣는 경우는 @CsvSource 로 구분하여 넣는다. 이때 구분자는 기본 , 이다. @ParameterizedTest @ValueSource(ints = {1,2,3}) // six numbers void paramedTest (int number) { assertThat(numbers).contains(number); }아래 예시는 1,2,3 은 통과, 4,5 를 넣으면 실패하는 로직을 확인하기 위해 만든 테스트이다. @ParameterizedTest @DisplayName(&quot; paramed Test -&amp;gt; 1,2,3 pass , 4,5 fail &quot;) @CsvSource(value={&quot;1,2,3&quot;,&quot;4,5&quot;}) void paremedTestWithFail(int number){ assertThat(numbers).contains(number); }@DisplayName위에서 보이듯이 메소드명 말고 테스트 이름을 붙여줄 때 사용한다. 위처럼 사용한 결과이다.테스트 명이 @DisplayName 어노테이션에서 사용한대로 나왔음을 알 수 있다. 3. Assertions &amp;amp; Assumptions위에서 말했듯이 단위 테스트는 화이트 테스트이기 때문에 우리가 작동하리라 예상한 방향이 있다.이를 실제 작동한 값과 비교해 테스트 결과를 내는게 이 메소드들이다.변수로는 우리가 예상한 값과 실제 값이 들어간다. @Test void split(){ String[] actual = &quot;1,2&quot;.split(&quot;,&quot;); assertThat(actual).isEqualTo(new String[]{&quot;1&quot;,&quot;2&quot;}) .containsExactly(&quot;1&quot;,&quot;2&quot;); }배열에서 어떤 값이 있는지 포함되어있는지 알고 싶을 땐, contains 사용. 오직 예상한 값만 있는지 확인하고 싶을때는 containsExactly 쓴다. 위의 메소드 실행하면 pass 나온다. “1,2” 인 스트링을 , 기준으로 자르면 “1”,”2” 만 있기에.@Test void split(){ String[] actual = &quot;1,2,3&quot;.split(&quot;,&quot;); assertThat(actual).isEqualTo(new String[]{&quot;1&quot;,&quot;2&quot;,&quot;3&quot;}) .containsExactly(&quot;1&quot;,&quot;2&quot;); }하지만 이렇게 하면 오류난다. 실제는 “1”,”2”,”3” 인데 우리가 기대한 값은 “1”,”2” 이기 때문에 !!assertThatThrownBy &amp;amp; assertThatExceptionOfTypeexception 던지는거 확인할 때 쓰는 메소드!! 아래 예시는 IndexOutOfException 나는지 테스트 하는거@Test@DisplayName(“charat outOfIndex test”)void charAtTest(){ int index = 3; /assertThatThrownBy/(()-&amp;gt;{ char actual = “abc”.charAt(index); }).isInstanceOf(IndexOutOfBoundsException.class).hasMessageContaining(“String index out of range: %d”,index);}OR assertThatExceptionOfType/(IndexOutOfBoundsException.class).isThrownBy(()-&amp;gt;{ char actual = “abc”.charAt(index);});이 정도로 간단히 쓰고 스프링 공부하거나 작은 내 토이프로젝트에 실제로 적용해보면서 공부해야겠다 !!그럼이만~~~~~" }, { "title": "해시 테이블 알고리즘, 설명과 java 구현, java collection framework hashmap 사용법", "url": "/posts/hash-algorithm/", "categories": "study", "tags": "IT, JAVA, hashalgorithm", "date": "2022-02-01 18:05:00 +0900", "snippet": "작은 거라도 TIL 정리하기로 함 !!코테 문제 풀때 기본기가 없으니 자신이 없는거 같아서 어차피 면접 대비도 할 겸 겸사 겸사 정리한다.엔지니어 대한민국님 해시테이블 유튜브 참고1. 해시 테이블 알고리즘key 를 입력 받아 hash 함수를 돌려 hash code 를 만든다. 이 hashcode 를 테이블 index 로 환산해 저장한다. key, value 가 있는 값을 저장할 때 사용한다 !!장점해시코드 자체가 인덱스를 만들때 사용되기에 검색할 필요 없어 조회가 빠르다.주의할 점대신 인덱스 를 만드는 hash 알고리즘이 좋지 않을 경우 , 배열 한 칸에 너무 많은 데이터 들어가야하기에 collision 이 일어난다.충돌 많은 경우 O(N) 까지 복잡도가 높아질 수 있다. 서로 다른 키로 같은 해시 코드를 가질 수 도 있음 서로 다른 코드가 배열 방 한정되어있기에 같은 인덱스로 같은 방 들어갈 수도 있음.이런 걸 모두 collision 이라고 한다.2. java 로 구현한 코드 (MAP 컬렉션 없이)public class HashTableEx { //key, value 저장할 node 생성 public class Node{ private String key; private String value; Node(String key, String value){ this.key=key; this.value=value; } //get, set 함수 생성 public void setValue(String value){ this.value= value; } public String getValue(){ return this.value; } } private LinkedList&amp;lt;Node&amp;gt;[] list ; // 테이블 크기 초기화 HashTableEx(int size){ this.list = new LinkedList[size]; } public int keyToHash(String key){ int hash=0; char[] keyToChars = key.toCharArray(); for(char c:keyToChars){ hash+=(int)c; } return hash; } // % 3 연산, 크기 3개로 하였기에 이 인덱스 벗어나지 않도록 public int hashToIndex(int hash){ int index = hash % 3 ; return index; } public void put(String key, String value){ int hash= keyToHash(key); int index = hashToIndex(hash); // key to hash -&amp;gt; hash to index 거쳐서 인덱스 분배함. //들어갈 방 인덱스로 세팅 LinkedList&amp;lt;Node&amp;gt; putList = list[index]; //들어갈 방에 아무도 없으면 방에 linkedlist 초기화 하고 add if(putList ==null){ putList = new LinkedList&amp;lt;Node&amp;gt;(); list[index]=putList; } // key 는 중복 될 수 없기에 같은 키 있으면 value 바꾸기 Node findNode = get(key); if(findNode == null){ putList.add(new Node(key,value)); }else{ findNode.setValue(value); } } public Node get(String key){ int hash= keyToHash(key); int index = hashToIndex(hash); LinkedList&amp;lt;Node&amp;gt; findList = list[index]; // key -&amp;gt; hash -&amp;gt; index 로 환산한 방 돌면서 key 찾기 for(Node node : findList){ if(node.key.equals(key)) return node; } return null; } public static void main(String[] args) { HashTableEx example = new HashTableEx(3); example.put(&quot;study&quot;,&quot;hard&quot;); example.put(&quot;play&quot;,&quot;more harder&quot;); example.put(&quot;eat&quot;,&quot;much more happier&quot;); example.put(&quot;play&quot;, &quot;^^&quot;); System.out.println(&quot;study &quot; + example.get(&quot;study&quot;).value); System.out.println(&quot;play &quot; + example.get(&quot;play&quot;).value); System.out.println(&quot;eat &quot;+ example.get(&quot;eat&quot;).value); }}3. HashMap 컬렉션으로 구현친절한 자바는 이걸 다 구현해놔서 이렇게 사용하면 된다 !!!Map&amp;lt;String, String&amp;gt; findByMap = new HashMap&amp;lt;&amp;gt;(); findByMap.put(&quot;study&quot;,&quot;hard&quot;); findByMap.put(&quot;play&quot;,&quot;more harder&quot;); findByMap.put(&quot;eat&quot;,&quot;much more happier&quot;); findByMap.put(&quot;play&quot;, &quot;^^&quot;); System.out.println(&quot;---------- use HashMap-------&quot;); System.out.println(&quot;study &quot; + findByMap.get(&quot;study&quot;)); System.out.println(&quot;play &quot; + findByMap.get(&quot;play&quot;)); System.out.println(&quot;eat &quot;+ findByMap.get(&quot;eat&quot;));" }, { "title": "spring JPA 사용해 세팅시 주의할 점 ! (spring.jpa.hibernate.ddl-auto)", "url": "/posts/jpa-ddl-setting/", "categories": "study", "tags": "IT, web, JPA", "date": "2022-01-27 18:05:00 +0900", "snippet": "플젝하다가 배운 거 정리하기 !! 이번 플젝에서는 JPA 쓰기로 했는데, 회원가입 구현하다가 설정 관련해 주의해야할 부분을 배우게 됐다.역시 직접 해보면서 깨닫는게 직빵이다.1. 배경과 문제점spring boot + JPA 로 간단한 회원가입 구현하고 있었다.요청에서 넘어온 정보를 dto 에 매핑 시키고 그냥 save 만 하면 되는 간단한 기능이었는데 이상하게 자꾸 로컬에서 새로 기동할 때마다 이전 데이터들이 날아갔다.. ?2. 원인application.properties 에 넣는 JPA 설정 중에 spring.jpa.hibernate.ddl-auto 가 있다.ddl-auto 라는 이름에서 유추할 수 있듯이 테이블 create, drop 을 자동으로 해주는 설정이다.JPA 사용하여 db 초기화 하는 세팅임.spring.jpa.hibernate.ddl-auto = create 라고 하면 실행시마다 기존 테이블을 드랍하고 새로 만든다.즉 내 로컬에서 spring.jpa.hibernate.ddl-auto = create 였기 때문에 발생한 문제였다.아니 근데 내 로컬에서 발생했으니까 ㅎㅎ아하~ 하고 말지 만약 내가 일하면서 운영계에 잘못해서 프로퍼티 세팅을 저렇게 올렸으면… ? 아찔하네요,,,,3. spring.jpa.hibernate.ddl-auto 세팅 프로퍼티 정리spring.jpa.hibernate.ddl-auto = create : hibernate 를 사용해서 db를 초기화하는 설정.property : Create - 실행시마다 기존테이블 드랍하고 새로 만든다. Update - 변경 분만 업데이트 Validate - 엔티티와 테이블이 정상 매핑되었는지만 확인 None - 값 무시spring boot 에서 기본 값은 db 가 h2 같은 임베디드이면 create-drop 이 기본이고 외부 db 커넥션 해놓는다면 none 이 기본이다.참고 - 스프링 공식 문서" }, { "title": "HTML 에 대하여", "url": "/posts/webdev-ch1-html/", "categories": "study", "tags": "IT, web, git", "date": "2022-01-23 16:05:00 +0900", "snippet": "온보딩 커리큘럼에 올린거 블로그에도 올린다. 1. HTML 표준의 역사는 어떻게 될까요?html 은 HyperText Markup Language 의 약어로 1991년 처음 발표 됐다. 텍스트, 이미지 등 웹 페이지에 표시되는 데이터들을 태그 형식으로 구조적 형태로 나타낸다. 1997 년 HTML3.2 가 W3C 권고안으로 표준으로 발표됨. w3c 가 의사결정이 느리자 Apple, Mozilla, Opera는 공동으로 WHATWG(Web Hypertext Application Technology Working Group)라는 그룹을 만들어 w3c와 함께 HTML5 를 제정했다.2.HTML 표준을 지키는 것은 왜 중요할까요?웹은 누가 어떤 플랫폼으로 (어떤 브라우저로) 사용할지 특정할 수 없기에 표준을 지키지 않으면 누가 접근하더라도 동일한 내용으로 출력되어야하는 원칙이 위반되고 누구나 원할하게 웹 페이지를 접근할 수 있어야한다는 웹 접근성이 훼손되기에 지켜야한다.3.XHTML 2.0은 왜 세상에 나오지 못하게 되었을까요?XML과 HTML을 합성하여 더 확장된 표현을 위해 XHTML 이 나왔다. 하지만, 하위 호환성을 지원하지 않아서 이전의 태그들로 작성된 것들이 사용되지 않을 수 있다는 문제점이 있었고, 사용하기 어렵다는 이유로 사용자들이 점점 줄어들면서 사양으로 접어들었다.4.HTML5 표준은 어떤 과정을 통해 정해질까요?W3C에서 정해져 공표된다 .5.브라우저의 역사는 어떻게 될까요?웹 브라우저란 웹 상에 있는 페이지들의 HTML 언어를 해석해서 내용을 화면에 정리하여 보여주는 프로그램이다. 웹 브라우저란 월드 와이드 웹(www)에서 정보를 검색,표현하고 탐색하기 위한 소트프웨어이다. 브라우저는 인터넷에서 특정 정보로 이동할수 있는 주소입력창(인터페이스)를 포함, 서버와 HTTP로 정보를 받을 수있는 네트워크 모듈도 포함한다. 1989년 영국에서 처음 만들어졌으며, 1990년대 넷스케이프와 IE 양강구조로 발전됐다. 마이크로 소프트 운영체제에 이 소프트웨어를 기본 탑재하면서 시장 점유율이 급격히 올라갔다. 그러나 MS 제품이 아닌 곳에서는 브라우저 지원을 중단하고 대체 브라우저들이 많이 생겨나면서 시장 점유율이 낮아졌다.6. Internet Explorer가 브라우저 시장을 독점하면서 어떤 문제가 일어났고, 이 문제는 어떻게 해결되었을까요?독점시장이기에 기술의 발전이 일어나지 않았다. 마이크로 소프트에서는 웹브라우저 개발팀을 해체하기까지했었다. 그러나 다른 브라우저의 점유율이 올라오니 위기감을 느낀 마이크로소프트는 다시 IE 의 새 버전을 내놓았다.7.현재 시점에 브라우저별 점유율은 어떻게 될까요? 이 브라우저별 점유율을 알아보는 것은 왜 중요할까요?크롬 - 65 %, 사파리 20 %, 엣지 4 % 파이어폭스 3 % , 기타 등등이다. (2021 기준) (https://en.wikipedia.org/wiki/Usage_share_of_web_browsers)개발을 할때 사용자 호환성이 가장 좋게 하기 위해서 어느 브라우저에 최적화를 해야할 지 판단하기 위함이다.### 8. 브라우저 엔진(렌더링 엔진)이란 무엇일까요? 어떤 브라우저들이 어떤 엔진을 쓸까요? 사용자가 요청한 콘텐츠를 화면에 표시해주는 것이다. HTML, CSS 등을 파싱하여 그린다. 서버에게서 전달받은 HTML 을 파싱하여 DOM 객체로 만들고, 외부 CSS 등을 파싱하여 스타일을 구축한다. 이를 합쳐 렌더 트리를 생성하고 화면상에 어디에 놓을지 정하고 그린다.크롬: Blink 사파리: Webkit 파이어폭스:Gecko 엣지 : EdgeHTML (MS 자체개발 렌더링 엔진)### 9.모바일 시대 이후, 최근에 출시된 브라우저들은 어떤 특징을 가지고 있을까요? 모바일에서도 잘 돌아가야하기에 가볍고 작은 화면에서 효율적으로 웹 콘텐츠를 보여주는데 최적화되어있다.10.HTML 문서는 어떤 구조로 이루어져 있나요?HEAD: HTML문서의 정보가 담겨 있다. 타이틀이나 HTML 버전, 메타 데이터 등등 BODY: 웹 페이지에 그리고자 하는 콘텐츠가 담겨 있다.&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt; &amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;!DOCTYPE html 태그 : HTML 버전을 말하며 HTML5 를 뜻한다. html 태그: html 루트 로 코드를 감싸주어야한다.### &amp;lt;head&amp;gt;에 자주 들어가는 엘리먼트들은 어떤 것이 있고, 어떤 역할을 할까요?style 태그 : css 같은 스타일을 입히는데 사용된다. 태그를 특성하고 그 태그의 스타일을 선언한다. &amp;lt;style&amp;gt; body{ background-color: #616A6B; } h1{ font-family: commanders; background-color: yellow; } h2{ font-family: algerian; background-color: cyan; } #first{ font-family: Castellar; background-color: green; color: blue; } .second{ text-align: right; background-color: white; font-size: 30px; color: red; } &amp;lt;/style&amp;gt;title 태그 : html 문서의 제목을 나타낸다.base 태그: URI 나 URL 을 선언한다. 페이지의 모든 링크의 베이스가 되는 URL 을 선언한다. &amp;lt;base href=&quot;https://media.geeksforgeeks.org/wp-content/uploads/&quot; target=&quot;_blank&quot; /&amp;gt;이런 식임.script 태그 : 클라이언트 사이드 스크립트 를 넣는다. 스크립트 자체를 써넣을 수 있고 외부 스크립트 파일을 첨부하는데에 사용할 수 도 있다. 주로 컨텐츠의 동적 변경을 위해 자바스크립트를 이 곳에 사용한다.meta 태그: 문서의 정보에 대해서 기술한다.attribute 에는 name: 프로퍼티 이름 정의할 때 사용 http-equiv: http 응답 헤더 사용할 때. content: 프로퍼티 값 채울 때 가 있다.&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&amp;gt;link 태그 : html 문서와 외부 리소스 연결할 때 사용한다. 주로 외부 css 등을 링크할 때 사용한다.(https://www.geeksforgeeks.org/html-link-tag/)11. 시맨틱 태그는 무엇일까요?이름만으로도 브라우저나 개발자가 어떤 역할을 하는 태그인지 알 수 있는 태그들을 뜻한다.article ,aside, footer, header, nav, section 등이 있다. section : 어떤 공통된 테마를 가진 컨텐츠의 묶음이다. article : 독립적이고 개별적인 컨텐츠 단위 header : 컨텐츠 소개와 링크들 footer : 저작권 정보 등 푸터에 들어가야할 정보들 nav : 내비게이션 링크들의 묶음을 감싼다. aside : 주변 정보들과 관계가 좀 떨어지는 정보들을 묶는다. (사이드바 같은)12. 시맨틱 엘리먼트를 사용하면 어떤 점이 좋을까요?시각장애가 있는 사용자가 스크린 리더를 사용하여 페이지를 탐색할 때도 도움이 되고 검색엔진이 태그 기반으로 페이지 내 키워드 우선 순위 판단하기에 검색 엔진 최적화에도 중요하다!! 그리고 div 연속보다 코드 가독성이 좋다.13. &amp;lt;section&amp;gt;과 &amp;lt;div&amp;gt;, &amp;lt;header&amp;gt;, &amp;lt;footer&amp;gt;, &amp;lt;article&amp;gt; 엘리먼트의 차이점은 무엇인가요?section&amp;gt;태그는 논리적으로 관계있는 컨텐츠들을 감싸는 태그이다. 이 안에 div, header, footer, article 들어갈 수 있다. 물론 article안에 섹션이 들어갈 수 있기는 하지만, section은 논리적으로 연관있는 콘텐츠의 묶음이고 article은 개별 정보이기에 section으로 article을 감싸는게 더 자연스럽다.14. 블록 레벨 엘리먼트와 인라인 엘리먼트는 어떤 차이가 있을까요?블록 레벨 엘리먼트는 항상 새 라인에서 시작하고, 페이지의 가로를 통째로 잡아먹는다. h1~h6 이런 헤딩 태그들이나 ol.ul 의 리스트들, div가 속한다.인라인 엘리먼트는 페이지 가로를 꽉 채우지 않고 오픈 태그와 클로즈 태그 사이에서 정의한 만큼의 공간만 차지한다. a em img span이런 태그들 !https://codeburst.io/block-level-and-inline-elements-the-difference-between-div-and-span-2f8502c1f95b" }, { "title": "웹 보안에 대하여 1 - 세션 기반 인증과 토큰 기반 인증", "url": "/posts/web-security-01/", "categories": "study", "tags": "IT, web, git", "date": "2022-01-21 17:00:00 +0900", "snippet": "프로젝트 회의 준비하면서 공부한 보안 관련 내용들 블로그에 올리기.확실히 다른 사람에게 말하려고 준비하다보니 더 열심히 찾아보고 자기자신부터 먼저 이해해보려고 노력하게 되서 좋다.많이 부족하지만 이렇게 하나하나 익혀가는 거지. 스터디의 중요성 !!ppt 파일로 만든 내용 블로그에 서식만 맞춰서 올리고 소스는 정리해서 깃헙 스터디 레포에 올려야겠다.1. 인증과 인가우선 인증과 인가 개념의 차이에 대해서 잡고 가야한다.웹 보안은 인증과 인가를 해주어 안전하게 정보를 주고 받게 하는 것이 목표 !인증 접근하는 대상이 누구인지 판단하는 것. 보통은 아이디, 패스워드를 통한 로그인으로 검증한다. 웹은 상태를 저장하지 않는 http 프로토콜을 사용하기에, 이를 보완하는 세션 기반, 토큰 기반 인증이 필요하다.인가 인증된 접근 대상이 어디까지 권한이 있는지 정하고 그에 따라서 행동하도록 허가하는 것. ex) 일반 사용자는 관리자 페이지 url 을 호출하더라도 들어갈 수 없음.👀 인증을 먼저 해주고 인가를 하는 구조로, 인증 종류에는 세션 기반 인증과 토큰 기반 인증이 있다 .2. 세션 기반 인증배경 http 는 상태를 저장하지 않는 stateless 한 프로토콜이기에 매번 요청시마다 인증해야하는 번거로움이 있다. (요청 - 응답 끝나면 바로 정보 싹 날아가서 다시 요청하면 누구세요? 함) 쿠키 인증 방식으로 인증 정보 자체를 쿠키에 넣어 브라우저 저장하면 정보가 탈취 당할 위험이 있다.플로우(1) 유저가 로그인 함(2) 서버는 세션 만들어서 서버 메모리에 저장한다. 이때 각 세션 정보를 가리키는 session id 가 부여된다.(3) 서버는 클라이언트에게 인증됐음과 함께 session id 를 전달해준다. (4) 브라우저에 session id 쿠키로 저장해놓고 요청시에 쿠키로 서버에 전달한다. (5) 서버는 session id 받은걸로 저장된 세션 정보랑 비교 검증 해보고 요청을 수행해 응답한다.장점 서버 측에서 사용자 상태 확인하기가 명확하다. ( 로그인 여부, 활동 여부 등 확인 명확) 쿠키 방식에 비해, 정보 자체는 서버에만 있기에 안전하다.단점 서버에서 정보 생성, 저장해야해서 다량의 사용자 있는 경우 서버 성능에 부하 발생 멀티 디바이스 (모바일, 웹 동시 사용) 에서 중복 로그인 방지 등 고려해야할 게 많다. 서버 확장시 서버 메모리에 저장한 세션 정보의 관리가 어려워진다. (서버 메모리에 세션 정보 저장하기 때문)3. 토큰 기반 인증배경 세션 인증 방식의 단점인 서버의 부담을 줄이고, 서버 확장성을 높이는데 유용한 방식. 세션 id 탈취로 인한 보안 취약점을 방지하고 싶다.알아야 할 용어 access token : 접근한 사용자가 정상적으로 인증되고 그에 따른 권한을 확인했을 때 발급된다. 발급되면 사용자가 요청시마다 첨부해서 보내기에 탈취 가능성이 있어 만료기간이 짧다. refresh token : access token 만료되었을 때 재발급을 위해 사용하는 토큰으로 access token 보다 유효기간이 길다. JWT (Json Web Token) :Json 객체를 통해서 관리되는 토큰 방식. 헤더, 페이로드, 서명으로 구성되어 있다.http header 에 담아서 서로 통신.클라이언트에 저장하기에 서버에서 클라이언트의 토큰 조작할 수는 없다. 2편 JWT 구현하기에서 더 자세한 설명 하겠다.플로우(1) 유저가 로그인 함(2) 서버는 유저 정보 확인 후 서명된 토큰을 발급한다.(3) 클라이언트 측에서 토큰 저장해 놓고 요청시마다 토큰을 http 헤더에 함께 보냄.(4-1) 서버는 요청과 함께 받은 토큰 검증 후 요청 수행해줌. (4-2) 토큰 검증시 만료된 토큰이라면 재발행 여부 확인함.👀단순한 구조로 하려면 그냥 access token 만 발급해주고 만료시마다 재인증하도록 할 수 있다. 하지만, access token 이 탈취되면 보안이 뚫려버린다.👀이를 보완하기 위해 access token의 유효기간은 짧게 하고refresh token을 함께 쓰는 것이 더 안전하다.3-1 Oauth 2.0토큰 인증 방식의 한 프로토콜이다.사용자가 다른 서비스의 기능을 아이디, 비밀번호 노출 없이도 사용할 수 있게 해준다. 이를 통해 한 서비스에서의 인증으로 다른 서비스 까지 사용할 수 있다.Oauth 2.0 이해를 위해 알아야할 용어 Resource Owner = User = 사용자 Client = 이용할 서비스 (ex. 내프로젝트.com ) Resource Server - 자원을 가지고 있는 서버 (Google, Facebook, …) Authorization Server - 인증 서버 (Google, Facebook의 인증 파트, …)장점 서비스는 사용자의 정보를 관리해야하는 부담을 덜 수 있음. 사용자는 이용하려는 서비스마다 개별적으로 가입해야하는 번거로움을 줄일 수 있음. 권한에 따라서 인증 뿐 아니라 다른 서비스의 여러 정보에 접근 가능. (ex. 페이스북 인증 후 친구 목록 가져오기)참고 자료인증과 인가Web Security: OAuth2 and OIDC – The Coders Tower세션 인증Session vs Cookie AuthenticationWeb authentication state - Session vs Cookie?HTTP 는 Stateless 한데 로그인은 어떻게 구현할 수 있을까? (세션/쿠키를 이용한 인증)토큰 인증Token 인증 방식이란?서버인증방식종류_세션/쿠키, 토큰방식OAuth와 춤을jwt 구현한 건 소스 좀 정리한 다음에 올려야겠다." }, { "title": "git 에서 untracked 파일 지우는 법 !", "url": "/posts/git-delete-untracked/", "categories": "study", "tags": "IT, web, git", "date": "2022-01-15 16:05:00 +0900", "snippet": "확실히 git 에 대한 개념을 잡고 나니 매일 얼레벌레 모든 파일을 다 올리던 과거에 비해서 나아졌다. 변경 사항이 많아도 올려야 할 파일들만 add 해서 쓰는데, 그러다 보니 git status 해보면 untracked file 이 많다.이때 파일들 지우는 법 !git clean -f 만약 폴더까지 지우고 싶으면git clean -fd 하면 폴더까지 깔끔히 지워짐 !!간단하지만 유용합니당" }, { "title": "java 의 return문 위치", "url": "/posts/java-return/", "categories": "study", "tags": "IT, web, JAVA, return문, return문위치", "date": "2022-01-05 19:05:00 +0900", "snippet": "너무 기본적인 것도 중간 중간 기록해 놓으려고 한다.자바를 사용하면서 함수 바깥으로 값을 보낼때 (반환할때) return문은 정말 질릴 정도로 사용했다고 생각했는데 오랜만에 간단한 문제를 풀다가 컴파일이 안되는 문제가 생겼다.return문 함수 안에서 사용한 값을 함수 바깥으로 보낼때 사용. 리턴하고자 하는 데이터의 자료형을 메소드 이름 옆에 명시해 주어야한다. 값을 리턴할 뿐 아니라 함수를 종료시키는 역할도 한다. 반대로 리턴할 자료형을 메소드 이름 옆에 적어주었다면, 반드시 리턴문이 있어야한다 !문제가 생겼던건 마지막 줄이었다.나는 간단한 문제를 풀면서 로직내 if 문들안에만 return 문을 적어놓은 것이다.public static boolean example (int i){ if (i &amp;gt; 0) { return true; }else { return false; }}이렇게 해둔 것이다. 이 경우 if 문안에 조건이 안 걸리는경우가 있을 수 있기에 컴파일이 되지 않는다.이를 방지하기 위해선 두 가지 방법이 있다.1) return null ; 같은걸 맨 아래 삽입하여 컴파일 되도록 함.2) 조건문 밖에 boolean result 같은 변수 만들고 그 변수값을 분기에 따라 조정후 리턴.나는 2 가 귀찮다고 저렇게 무지하게 쓴 것이당.. 제대로 하자 제대로,, 그래도 이렇게 기본 한번 잡고 간당 !!" }, { "title": "1일 1로그 100일 완성 IT 지식 - 알고리즘", "url": "/posts/100days-log/", "categories": "study", "tags": "IT, web, 데이터베이스, DB, mysql, postgresql, sqlite, db비교", "date": "2022-01-05 19:05:00 +0900", "snippet": "1일 1로그 100일 완성 책을 읽으면서 조금씩 정리해놓으려고 한다. 조금 읽어 봤는데 정말 도움된다. 그리고 동시에 비IT인들도 쉽게 이해 가능할듯. 책 좋당.알고리즘결과가 정확히 계산되도록 보장된 일련의 단계로 , 각 단계는 명확한 기본 연산으로 이루어져있다. 상상력이 없는 개체가 수행하더라도 연산의 의미와 수행 방법에 이견이 없을 정도로 상세하고 정확하게 이루어져야 한다. 선형 알고리즘 계산 시간이 데이터의 양에 정비례하거나 선형적으로 비례할 때. 초기화를 하고, 각 항목을 차례로 검사하고 간단한 계산을 수행한다는 비슷한 꼴을 가지고 있음복잡도는 데이터 수에 비례함 : N 이진 검색확인 또는 비교 단계를 거치면서 항목 들이 두 그룹으로 나뉘고 한쪽 그룹은 다음 대상에서 고려 제외할 수 있다.복잡도는 밑이 2인 로그에 비례함. : log2n중요한 건 아무리 데이터 수가 늘어도 계산 시간이 천천히 증가한다는 것 선택 정렬과 퀵 정렬선택 정렬의 경우, 첫번째 값을 두번째 값부터 마지막 값까지 비교해서 첫번째 값을 정하고 그 다음엔 두번째 값부터 같은 방식 반복한다. 복잡도는 데이터의 제곱 : n^2데이터가 조금 늘어날때마다 계산 시간이 너무 많이 소요된다. 퀵 정렬은 한번 훑어보면서 두 그룹으로 나누고, 그 그룹내에서 또 나누고 나누면서 정렬하는 방법이다.복잡도는 nlog₂n 각 소스 구현한건 나중에 추가하겠다." }, { "title": "미니 프로젝트에서 사용할 DB 고르기 / mysql vs PostgreSQL vs SQLite", "url": "/posts/about-database/", "categories": "study", "tags": "IT, web, 데이터베이스, DB, mysql, postgresql, sqlite, db비교", "date": "2022-01-05 19:05:00 +0900", "snippet": "동기들이랑 하는 미니 프로젝트 DB 선정을 위해 이것저것 찾아본 거 정리하기.미니 프로젝트에 사용할 DB 를 선정하기 위해선 1) DB 종류별 특징 조사하기2) 우리 프로젝트 데이터에 맞는 DB 선정 하고 이유 정리하기이 두가지가 필요하다. 아무래도 이직, 취직을 생각하면서 하는 프로젝트 다 보니 단순히 기술 스택을 사용하는 것 보다 ‘왜 그것을 사용했는지’ 를 꼼꼼히 생각해보고자 한다.1 . DB 간의 차이점 알아보기 .우선은 SQL 과 NoSQL 차이부터 공부하고 나눠 봤다.NoSQL = Not only SQL 로 비관계형 데이터베이스이다. SQL 에서의 행과 열 테이블 식의 데이터 관리가 아닌 다양한 데이터 모델로 저장 , 관리할 수 있도록 해준다.mongoDB : documentDB로 data 를 json 형태로 저장한다. 보통 sql 에선 행과 열 형태로 저장하기에 데이터 형식으 제약이 많은데 비해서 좀 더 자유로음. 카산드라db : 엄청 많은 양의 데이터를 빨리 읽어야함. Dynamo DB : 키 밸류 DB 로 많은 데이터 뽑음.GraphDB : 페이스북 같은 곳에서 사용하는 것으로 데이터 간 관계가 복잡해 entity 형식으로 관리해야 접근이 빠른 데이터에 적합하다. 이렇게 종류와 특징에서 보듯이 NoSQL은 대용량의 복잡한 특정 상황에서 유리하기에 미니 프로젝트 같은 작은 규모에 단순한 구조에서는 크게 장점을 발휘하지 못한다.그냥 SQL 중 하나 골라서 쓰면 될 듯 .2. Sql 중 MySQL vs PostgreSQL vs SQLiteMySQL 퍼포먼스 대비 가벼워서 속도가 중요한 시스템에도 괜찮다. 그리고 커뮤니티가 크다 보디 이용중에 문제가 있어도 참고할 게 많다 . 설치가 쉽고 서포트 커뮤니티가 커서 대부분의 웹 사이트나 웹 기반 어플리케이션에 적당하다. 복제 기능이 있어 수평확대가 쉽다. 대신 읽기와 쓰기 작업이 동시에 일어나는 경우에는 트랜잭션에 따른 데이터 무결성이 완전하지 않아서 문제가 될 수 있음. 표준 SQL 지원하지 않는 부분도 있음 (간결함 때문에 미지원)PostgreSQL 확장성이 좋아 커스텀이 용이하고 데이터 타입을 여러개 지원한다. (다양한 기능 사용 가능) 하지만 역으로 이런 다양성때문에 서포트를 찾기 어려울 수 있다. 복잡하거나 커스텀이 필요하거나, 다른 개발 도구들과 호환해야할 때 장점이 되긴하지만 ㅠㅠ 표준 SQL 을 준수한다. 대신 간단히 읽기만 하면 되는 건데 과하게 사용할 수 있음.SQLite 서버리스로 설치나 셋업이 필요없이 어플리케이션 단에서 실행된다. 데이터가 적거나 방문자수가 적은 작은 단위 어플리케이션 다룰 때 사용하면 좋다. 혹은 에어컨이나 이런 임베디드 db 필요할때 사용하면 좋다.3. 우리 프로젝트에선 뭘 사용하면 좋을까? 우리가 만들고자 하는건 데이터 크기는 엄청나게 많을 거 같지는 않음. 읽기를 여러번 해야해서 데이터를 읽어오는 속도가 빨라야할 것 이라고 생각함. 엄청난 커스텀이 필요할 것 같지는 않고 간단한 기능만 사용할 듯.세 가지 특징을 봤을 때, 사용이 간단하면서 속도가 좋은 mysql 사용하는게 좋을 것 같음! postgreSQL 도 좋아 보이지만 이 db 의 장점을 충분히 못 누릴 거 같음." }, { "title": "clojure 로 hello world 찍기", "url": "/posts/clojure-hello-world/", "categories": "python", "tags": "IT, clojure", "date": "2021-08-17 19:00:00 +0900", "snippet": "어차피 쉬엄쉬엄 사는 하반기 재밌는거나 많이 해보자.clojure 를 쓰는 회사도 있다고 들어서 호기심이 생겼다.그래서 그게 뭔데?함수형 프로그래밍? 나도 해보련다~~~clojure 란?리스프 프로그래밍 언어의 한 종류로 JVM 상에서 돌아가는 장점을 가진 함수형 프로그래밍 언어이다.간단 소개긴한데 모르는 개념이 너무 많다. 일단 기본적으로 난 리스프를 안 써봤고, 함수형 프로그래밍도 잘 모른다.일단 부딪혀보기일단 오늘은 clojure 로 hello world 찍는 법 !1. clojure 설치mac OS 인 경우 쉽게 설치 가능하다.brew install clojure/tools/clojure참고 Hello world 찍기(ns clojure.examples.hello // 네임스페이스 지정 (:gen-class))(defn hello-world [] (println &quot;Hello World&quot;)) // hello world 찍기(hello-world) 일단 이렇게 간단히 프린트만 하는 걸 짜고 실행해봤다.실행은 뭐 복잡한거 깔 필요없이 커맨드 창에서 해당 .clj 파일 있는 경로에서 clj 파일이름.clj 하면 실행된다.이걸로 간단한 웹 백엔드를 짜보려고 한다. 많이 어려우려나?일단 가보자고" }, { "title": "세션과 쿠키 이야기,, 즐거운 웹 생활", "url": "/posts/session-and-cookie/", "categories": "python", "tags": "IT, web, web programming, cookie, session", "date": "2021-03-18 19:00:00 +0900", "snippet": "세션과 쿠키는 대충 들어본 적은 있지만 정확히 정리하고 넘어간 적 없다.요즘 팀 보안담당 업무를 하면서 모의해킹 연습을 하는데 쿠키, 세션이 조금 헷갈렸다.마침 듣고 있는 인강에도 나와서 간단하게 정리하고 가야지.1. 쿠키사용자 컴퓨터에 저장하며, 주로 사용자가 어떤 리퀘 보내는지 트랙킹하는 용도로 많이 사용된다.그래서 우리가 어떤 사이트 처음가면 쿠키 수집을 허용하시겠습니까 ? 이런 메시지 뜨는 것 우리가 가지고 있는 웹서핑한 기록인 쿠키를 수집하면 우리에 대한 정보를 넘겨주는 꼴!!2. 세션시스템 서버 메모리에 저장하거나 redis 같이 단발성 저장하는 것.임의의 세션 아이디로 사용자를 구분하는 키로 씀.이걸로 개개인 사용자를 구분할 수 있기에 보안적인 측면에서 사용한다. 로그안하고 다른 페이지 넘어가도 그 사람인지 인증하기 위해선 세션 체크가 필요 !모의해킹 해볼때는 이 세션 값 탈취해서 다른 창 띄워서 사용 가능한지 해봤다. 세션 아이디를 만들고 부여하는건 사용자를 구분할 수 있도록 암호화-복호화도 하고 어쩌구 저쩌구 복잡한데 flask 에서는 라이브러리가 있어 사용할 수 있다고 한다.아마 다른 언어나 프레임워크도 마찬가지로 라이브러리 있겠지? 하나하나 다 어케해요…어쨌든 역시 실전으로 고민해봐야 머리에 잘 남는다 ^^…나같은 무근본은 기초 지식도 헷갈리는데 경험이 사람을 만든다 하ㅎ ㅏ" }, { "title": "flask 가 뭔데..? flask blueprint", "url": "/posts/flask-blueprint/", "categories": "python", "tags": "IT, 파이썬, python, flask, web, flask blueprint", "date": "2021-03-16 19:00:00 +0900", "snippet": "저번 스터디에서는 간략하게나마 django 를 써봤는데, 이번에는 flask 를 써보게 됐다. 까먹기전에 써놓기.blueprint 라는 개념을 배웠는데, 아직 완전히 이해한 거 같지는 않지만 어렴풋이 느끼기에는 django 랑 flask 의 큰 차이 같다. 예전 포스팅에서 해봤듯이 django 에서는 컴포넌트를 붙일때 따로 폴더 경로에 몰고 url 을 지정해주는 파일이 있었다. (urldispatcher 역할을 하는 파일. )은근 헷갈리기도 하고 초보인 내 입장에서는 여기서 연결 잘못해서 헤매기도 했다.근데 flask 에서는 blueprint라는 컴포넌트를 사용해서 url 매칭을 자유롭게 할 수 있게 도와준다.메인 서버를 띄울 곳에서만 @. route 를 사용하고 나머지 컴포넌트들에서는 각 컴포넌트를 이름을 가진 블루프린트 객체로 지정한뒤에 메인서버에서 부르기만 하면 된다.이게 무슨 말인가 싶겠지만, 예제 소스를 보면 조금 이해가 간다.폴더 구조가 아래와 같이 되어있고, 서버는 server.py 에서만 띄우고자 한다.sub ㄴ blutest.pysub2 ㄴ bluetest2.pyserver.pybluetest.py 소스from flask import Blueprintblue_test = Blueprint(&#39;myTEST&#39;, __name__) @blue_test.route(&#39;/hello&#39;)def test(): return &#39;TEST 입니당&#39;bluetest2.py 소스from flask import Blueprintblue_test2 = Blueprint(&#39;myTEST2&#39;, __name__) @blue_test2.route(&#39;/hello&#39;)def test(): return &#39;두번째 테스트지롱&#39;서버 소스from flask import Flaskfrom sub import bluetestfrom sub2 import bluetest2app = Flask(__name__)app.register_blueprint(bluetest.blue_test, url_prefix=&#39;/test&#39;)app.register_blueprint(bluetest2.blue_test2, url_prefix=&#39;/test2&#39;) # 서로 다른 경로 if __name__ == &#39;__main__&#39;: app.run(host=&#39;0.0.0.0&#39;, port=&#39;8088&#39;)이런식으로 쉽게 경로를 부여할 수 있다.초보자인 내 입장에서는 이게 더 쉬워보인다. (물론 내가 100퍼 이해한 거 같진 않지만 ㅎㅎ)기능 별로 폴더 따고 하나씩 경로 지정해 쓰면 편할 거 같다." }, { "title": "파이썬+셀레니움으로 멜론 플레이리스트 유투브로 옮기는 봇 만들기", "url": "/posts/python-youtube-bot/", "categories": "python", "tags": "IT, 파이썬, selenium, beatifulsoup, 셀레니움, 자동화", "date": "2021-03-15 12:30:00 +0900", "snippet": "우연히 김혜리의 필름클럽에 나온 노래를 모아 놓은 멜론 플레이 리스트를 발견했다. 유투브 뮤직 유저인데, 쫌쫌따리 옮겨오는건 귀찮잖아요,,, 크롤링만 할 수 있다면 금방 짤 수 있을거 같아서 시작했는데 생각보다 난관이 많았다.. 셀레니움 이란 ? 무료 자동화 테스트 툴로, html 개체 잡아서 원격 제어하는 용도로 사용한다.to do 멜론의 플레이리스트 긁어오기 파싱해서 곡 제목, 가수로 정리하기 유투브 로그인하기 플레이 리스트에 하나씩 추가하기일단 풀 코드는 https://github.com/yejinha/mini_proj/tree/main/melon2youtube에 있다. 준비물 : 크롬이나 사파리 웹드라이버 (나는 크롬 웹드라이버 썼음.)1. 멜론의 플레이리스트 긁어오기우선 가져오고자하는 멜론 플레이리스트를 긁어와야해서 웹 드라이버로 창 하나 열어준다. from selenium import webdriver driver = webdriver.Chrome(&#39;./chromedriver&#39;) # 경로가 아니라 파일명임. 확장자 없음 driver.get(playlist_url) # 플레이리스트 화면 열기 (원하는 플레이리스트 url 넣으면 된다.) html = driver.page_source soup = BeautifulSoup(html, &#39;html.parser&#39;) 일단 죽 긁어오고 파싱을 하는데 , 이때 플레이리스트 화면에서 f12로 화면 돔 구조 살펴보고 그에 맞게 짜야한다.멜론, 지니 등 다 범용으로 쓸 수 있게 하고 싶었으나 플랫폼마다 화면 구조가 다를테니 약간의 노가다 성이 있음… 심지어 일반 사용자가 공유한 플레이리스트랑 dj 로 등록된 사용자가 올린 플레이리스트의 화면도 돔 구조가 달랐다.이때 알았어야 하는데 차라리 그냥 쫌쫌따리 치는게 더 빠르단 걸 ^^….2. 파싱해서 곡 제목, 가수로 정리하기f12 로 구조 파악하고 곡 제목/ 가수 부분에 셀렉터를 가져온다. 클릭하고 copy &amp;gt; copy selector 클릭해서 사용. title = soup.select( &#39;#songList &amp;gt; div.section_playlist &amp;gt; #pageList &amp;gt; #frm &amp;gt; div.tb_list &amp;gt; table &amp;gt; tbody &amp;gt; tr &amp;gt; td.t_left &amp;gt; div.pd_none &amp;gt; div.ellipsis &amp;gt; a.btn_icon_detail &amp;gt; span&#39; ) singer = soup.select( &#39;#songList &amp;gt; div.section_playlist &amp;gt; #pageList &amp;gt; #frm &amp;gt; div.tb_list &amp;gt; table &amp;gt; tbody &amp;gt; tr &amp;gt; td.t_left &amp;gt; div.wrapArtistName &amp;gt; #artistName&#39; )selector 사용해서 파싱해낼 부분만 지정하면 쉽게 나온다.3. 유투브 로그인하기 &amp;amp; 플레이리스트 추가솔직히 여기가 제일 오래 걸렸다.기존에 사용하던 계정으로 하려니까 계속 자동화 툴이어서 보안상 막혀버리는거.. 헤더에 별 난리를 쳐도 계속 걸림.. 다른 구글로그인하는 사이트 (ex. 인프런) 으로 경유하려는 것도 막힘.여기서 솔직히 포기하고 싶었지만, 쏟은 시간이 아까웠다..근데 무슨 유투브 댓글에 그냥 새 계정 파서 하면 된다는거…? 진짜 해보니까 잘 됐다.. 코드는 고친게 없는데 새 계정 파니까 되네..? 어떤 기준으로 잡는건지. 어쨌든 이제 경유도 안되니까 테스트용 계정 하나 파서 사용하는 것 추천로그인 하는 기능 자체는 그냥 입력창 개체 선택 -&amp;gt; 입력 -&amp;gt; 확인버튼 개체 선택 -&amp;gt; 클릭 이 순이다. driver.get(&#39;https://www.youtube.com/&#39;); # 유튜브 접속 time.sleep(15) # 로그인 동작 시작 lg_menu = WebDriverWait(driver,timeout=100).until(EC.presence_of_element_located((By.XPATH,&quot;/html/body/ytd-app/div/div/ytd-masthead/div[3]/div[3]/div[2]/ytd-button-renderer/a/paper-button/yt-formatted-string&quot;))) # 실행합니다. lg_menu.click() idd = WebDriverWait(driver,timeout=100).until(EC.presence_of_element_located((By.NAME,&#39;identifier&#39;) )) idd.send_keys(id)여기서 time.sleep 과 WebDriverWait 을 둘 다 썼다. 원래는 time .sleep 만 가지고 다음 창이 뜨기까지 기다리도록 제어하려고 했는데 자꾸 이런 에러가 떴다.stale element reference : element is not attached to the page document.찾아보니까 동적인 제어를 하는 경우, 화면창에는 버튼이 뜬거 같아도 완전히 로드가 안되는 경우가 있나보더라.그래서 사용하는게 WebDriverWait -&amp;gt; 이걸로 element 가 뜰때까지 기다리도록 한다.더 자세한 사항은 여기 에서 확인할 수 있다. (공식 문서)간략히 설명하자면 타임아웃 시간을 정해놓고 특정 개체 (여기서는 액션에 필요한 버튼) 이 로드될때까지 기다리도록 명시적으로 표현할 수 있다.개체를 표기하는 방법은 위의 코드에서도 보이듯이 xpath, name, class 등이 가능하다.플레이리스트 추가하는 건 이런 개체 선택 -&amp;gt; 추가 버튼 클릭의 연속이었다.어쨌든 완성하고 나니까 뿌듯하다… 짜고 나니까 간단한데 왜 이렇게 오래 걸렸나 몰라.내가 이 개고생을 하게 된 플레이리스트 이거 백번 들을거야 ㅠ…" }, { "title": "Enable Google Page Views", "url": "/posts/enable-google-pv/", "categories": "Blogging, Tutorial", "tags": "google analytics, pageviews", "date": "2021-01-04 08:32:00 +0900", "snippet": "This post is to enable Page Views on the Chirpy theme based blog that you just built. This requires technical knowledge and it’s recommended to keep the google_analytics.pv.* empty unless you have a good reason. If your website has low traffic, the page views count would discourage you to write more blogs. With that said, let’s start with the setup.Set up Google AnalyticsCreate GA account and propertyFirst, you need to set up your account on Google analytics. While you create your account, you must create your first Property as well. Head to https://analytics.google.com/ and click on Start Measuring Enter your desired Account Name and choose the desired checkboxes Enter your desired Property Name. This is the name of the tracker project that appears on your Google Analytics dashboard Enter the required information About your business Hit Create and accept any license popup to set up your Google Analytics account and create your propertyCreate Data StreamWith your property created, you now need to set up Data Stream to track your blog traffic. After you signup, the prompt should automatically take you to create your first Data Stream. If not, follow these steps: Go to Admin on the left column Select the desired property from the drop-down on the second column Click on Data Streams Add a stream and click on Web Enter your blog’s URLIt should look like this:Now, click on the new data stream and grab the Measurement ID. It should look something like G-V6XXXXXXXX. Copy this to your _config.yml file:google_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID # Google Analytics pageviews report settings pv: proxy_endpoint: # fill in the Google Analytics superProxy endpoint of Google App Engine cache_path: # the local PV cache data, friendly to visitors from GFW regionWhen you push these changes to your blog, you should start seeing the traffic on your Google Analytics. Play around with the Google Analytics dashboard to get familiar with the options available as it takes like 5 mins to pick up your changes. You should now be able to monitor your traffic in real time.Setup Page ViewsThere is a detailed tutorial available to set up Google Analytics superProxy. But, if you are interested to just quickly get your Chirpy-based blog display page views, follow along. These steps were tested on a Linux machine. If you are running Windows, you can use the Git bash terminal to run Unix-like commands.Setup Google App Engine Visit https://console.cloud.google.com/appengine Click on Create Application Click on Create Project Enter the name and choose the data center close to you Select Python language and Standard environment Enable billing account. Yeah, you have to link your credit card. But, you won’t be billed unless you exceed your free quota. For a simple blog, the free quota is more than sufficient. Go to your App Engine dashboard on your browser and select API &amp;amp; Services from the left navigation menu Click on Enable APIs and Services button on the top Enable the following APIs: Google Analytics API On the left, Click on OAuth Consent Screen and accept Configure Consent Screen. Select External since your blog is probably hosted for the public. Click on Publish under Publishing Status Click on Credentials on the left and create a new OAuth Client IDs credential. Make sure to add an entry under Authorized redirect URIs that matches: https://&amp;lt;project-id&amp;gt;.&amp;lt;region&amp;gt;.r.appspot.com/admin/auth Note down the Your Client ID and Your Client Secret. You’ll need this in the next section. Download and install the cloud SDK for your platform: https://cloud.google.com/sdk/docs/quickstart Run the following commands: [root@bc96abf71ef8 /]# gcloud init~snip~Go to the following link in your browser: https://accounts.google.com/o/oauth2/auth?response_type=code&amp;amp;client_id=XYZ.apps.googleusercontent.com&amp;amp;redirect_uri=ABCDEFGEnter verification code: &amp;lt;VERIFICATION CODE THAT YOU GET AFTER YOU VISIT AND AUTHENTICATE FROM THE ABOVE LINK&amp;gt;You are logged in as: [blah_blah@gmail.com].Pick cloud project to use:[1] chirpy-test-300716[2] Create a new projectPlease enter numeric choice or text value (must exactly match listitem): 1[root@bc96abf71ef8 /]# gcloud info# Your selected project info should be displayed here Setup Google Analytics superProxy Clone the Google Analytics superProxy project on Github: https://github.com/googleanalytics/google-analytics-super-proxy to your local. Remove the first 2 lines in the src/app.yaml file: - application: your-project-id- version: 1 In src/config.py, add the OAUTH_CLIENT_ID and OAUTH_CLIENT_SECRET that you gathered from your App Engine Dashboard. Enter any random key for XSRF_KEY, your config.py should look similar to this #!/usr/bin/python2.7__author__ = &#39;pete.frisella@gmail.com (Pete Frisella)&#39;# OAuth 2.0 Client SettingsAUTH_CONFIG = { &#39;OAUTH_CLIENT_ID&#39;: &#39;YOUR_CLIENT_ID&#39;, &#39;OAUTH_CLIENT_SECRET&#39;: &#39;YOUR_CLIENT_SECRET&#39;, &#39;OAUTH_REDIRECT_URI&#39;: &#39;%s%s&#39; % ( &#39;https://chirpy-test-XXXXXX.ue.r.appspot.com&#39;, &#39;/admin/auth&#39; )}# XSRF SettingsXSRF_KEY = &#39;OnceUponATimeThereLivedALegend&#39; You can configure a custom domain instead of https://PROJECT_ID.REGION_ID.r.appspot.com.But, for the sake of keeping it simple, we will be using the Google provided default URL. From inside the src/ directory, deploy the app [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor: [/tmp/google-analytics-super-proxy/src/app.yaml]source: [/tmp/google-analytics-super-proxy/src]target project: [chirpy-test-XXXX]target service: [default]target version: [VESRION_NUM]target url: [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse Visit the deployed service. Add a /admin to the end of the URL. Click on Authorize Users and make sure to add yourself as a managed user. If you get any errors, please Google it. The errors are self-explanatory and should be easy to fix. If everything went good, you’ll get this screen:Create Google Analytics QueryHead to https://PROJECT_ID.REGION_ID.r.appspot.com/admin and create a query after verifying the account. GA Core Reporting API query request can be created in Query Explorer.The query parameters are as follows: start-date: fill in the first day of blog posting end-date: fill in today (this is a parameter supported by GA Report, which means that it will always end according to the current query date) metrics: select ga:pageviews dimensions: select ga:pagePathIn order to reduce the returned results and reduce the network bandwidth, we add custom filtering rules 1: filters: fill in ga:pagePath=~^/posts/.*/$;ga:pagePath!@=. Among them, ; means using logical AND to concatenate two rules. If the site.baseurl is specified, change the first filtering rule to ga:pagePath=~^/BASE_URL/posts/.*/$, where BASE_URL is the value of site.baseurl. After Run Query, copy the generated contents of API Query URI at the bottom of the page and fill in the Encoded URI for the query of SuperProxy on GAE.After the query is saved on GAE, a Public Endpoint (public access address) will be generated, and we will get the query result in JSON format when accessing it. Finally, click Enable Endpoint in Public Request Endpoint to make the query effective, and click Start Scheduling in Scheduling to start the scheduled task.Configure Chirpy to Display Page ViewOnce all the hard part is done, it is very easy to enable the Page View on Chirpy theme. Your superProxy dashboard should look something like below and you can grab the required values.Update the _config.yml file of Chirpy project with the values from your dashboard, to look similar to the following:google_analytics: id: &#39;G-V6XXXXXXX&#39; # fill in your Google Analytics ID pv: proxy_endpoint: &#39;https://PROJECT_ID.REGION_ID.r.appspot.com/query?id=&amp;lt;ID FROM SUPER PROXY&amp;gt;&#39; cache_path: # the local PV cache data, friendly to visitors from GFW regionNow, you should see the Page View enabled on your blog.Reference Google Analytics Core Reporting API: Filters &amp;#8617; " }, { "title": "얼레벌레 django 따라하기 2 - postgresql db 세팅해보기", "url": "/posts/django3-postgresql-setting/", "categories": "python", "tags": "IT, 파이썬, python, django, web, postgresql", "date": "2020-04-12 17:00:00 +0900", "snippet": "기본 sqlite 설정 말고, postgresql 연결해봤다.to do default db 를 postgresql 로 해주기 db 여러개 사용하기 - database router 사용**실습 환경은 mac OS1. postgresql 설치우선 로컬에 postgresql 설치해서 db 생성한다.brew install postgresql ^^ 너무 간단하죵?2. 유저 설정해주기기본적으로는 로컬 사용자가 유저로 등록되지만, db에서 테이블 생성하고 변경하고 기타 등등하는 유저 등록해준다.psql postgres # 로컬 사용자 게정으로 일단 들어감 CREATE ROLE 생성할 유저이름 WITH LOGIN PASSWORD &#39;사용할 비번&#39;; # 유저 생성 ALTER ROLE 생성한 유저이름 CREATEDB # db 생성 권한 부여 \\q # postgresql 종료psql postgres -U 생성한 유저 이름 # 생상한 유저로 들어가 확인 \\du # 유저리스트 확인 List of roles Role name | Attributes | Member of -----------+------------------------------------------------------------+----------- hayejin | Superuser, Create role, Create DB, Replication, Bypass RLS | {} ## 로컬 사용자 yj | Create DB | {} ## 추가한 사용자3. db 생성해주기사용할 db 생성해준다.psql postgres CREATE DATABASE sampleDB ENCODING &#39;utf-8&#39;; # db 생성하면서 인코딩 타입 정해준다. ALTER database sampleDB owner to yj; #사용할 사용자에게 권한주기 grant all on database sampleDB to yj with grant option;이제 이 db 를 쟝고의 모델이랑 연결해주기만 하면 된다.Django model 과 postgresql 연결하기기본 지식모델은 실제 데이터베이스와 객체를 연결하는 역할을 한다.즉 모델을 생성하였다면 이러저러한 내용물을 가지는 객체의 설계도를 선언한 것과 같다.실질적으로 데이터베이스에 이 구성대로 테이블을 만들고 값을 조작하기 위해서는 어플리케이션을 통해서 동기화해야한다.이 과정이 마이그레이션이다. 모델을 생성함 –&amp;gt; 마이그레이션 통해 설정대로 데이터 베이스에 구현하라고 마이그레이션 시켜야함이 과정을 거쳐야지 실제 데이터베이스에 우리가 사용하고자하는 내용대로 테이블이 생성된 것이다.ORM 을 사용하여 그 이후에 CRUD 는 함수 코딩을 통해 할 수 있다.이 필수 과정을 하기 위해서는 이 모델을 어느 데이터베이스에 테이블로 생성할지를 정의해야한다.psycopg2 설치하기.psycopg2 는 파이썬에서 사용하는 postgresql 어댑터 라이브러리다. pip install psycopg2 로 설치해준다 ^^1. 기본 설정 postgresql 로 하기postgresql 데이터베이스 설정 명시이제 postgresql 사용하겠다고 설정을 명시해준다. 프로젝트의 설정파일인 settings.py 에 적어준다.DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.postgresql_psycopg2&#39;, ## 어댑터 명시 &#39;NAME&#39;: &#39;sampledb&#39;, #사용할 db 이름 &#39;USER&#39;:&#39;yj&#39;, #테이블 생성 권한 있는 유저 &#39;PASSWORD&#39;:&#39;비밀번호&#39;, &#39;HOST&#39;:&#39;127.0.0.1&#39;, # 로컬에 설치하여 사용하니까 로컬호스트 &#39;PORT&#39;:&#39;5432&#39;, # postgresql 기본 포트 },}서버 올려서 확인관리자 페이지 통해서 간단히 확인해볼 수 있다.기본은 별로 어렵지 않다. 그냥 어댑터만 잘 깔면 괜찮음 ㅎㅎ2. db 여러개 사용하기 - database router 사용모종의 이유로 모델마다 사용하는 db 를 분리해주고 싶을 때가 있을 것이다. 그 경우 어떻게 하는지 해봤다. 여기서는 database router 사용한다.공식 레퍼는 여기여러 db 설정해주기 - settings.py나는 디폴트는 기본 설정인 sqlite 사용하고, postgreE 모델만 postgresql로 들어가도록 했다.DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;), }, &#39;postgre&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.postgresql_psycopg2&#39;, &#39;NAME&#39;: &#39;sampledb&#39;, &#39;USER&#39;:&#39;yj&#39;, &#39;PASSWORD&#39;:&#39;비번&#39;, &#39;HOST&#39;:&#39;127.0.0.1&#39;, &#39;PORT&#39;:&#39;5432&#39;, },} database router 설정해주기어떤 모델은 어느 db 에 저장하라고 라우팅 설정을 해줘야한다. 어차피 setting.py 에 경로 명시하니까 아무데나 라우터 파일 만든다. 라우터 파일에는 여러 메소드가 있는데 가장 필요한 기본 메소드만 했다.from django.conf import settingsclass PostgresqlRouter: ## 모델의 앱 이름이 postgreE 면 postgre 란 이름의 db 로 가라고 라우팅 해줘야함 def db_for_read(self,model,**hints): # select if model._meta.app_label == &#39;postgreE&#39;: return &#39;postgre&#39; return None def db_for_write(self,model,**hints): # insert update delete etc if model._meta.app_label == &#39;postgreE&#39;: return &#39;postgre&#39; return None def allow_relation(self,obj1,obj2,**hints): #다른 db 조작할때 사용할 건지. 나는 복잡하게 설정하기 싫어서 그냥 true 로 다 허용 return True def allow_migrate(self,db,app_label,model_name=None,**hints): #마이그레이션 할때 관심있는 모델의 변화만 할건지 정해줄 수 있다. 예를 들어 나랑 관계없는 모델 변화 마이그레이션이면 패스할 수 있다. # 나는 역시 복잡한거 싫어서 일단 전체 마이그레이션 한다. return True모델 메타 데이터에 앱 이름 명시 (선택사항)여기서 주목해야할 부분은 model._meta.app_label 부분이다. 모델명으로 하려면 model._meta.model_name 으로도 명시해 줄 수 있다. 이건 더 세세하게 쪼개는거 겠지. 나는 그냥 지금은 한 앱 내의 모든 모델은 이쪽 db 로 처리하세요 하는 뜻으로 앱 이름으로 해줬다. 이를 위해서는 모델 메타데이터에 앱 이름 명시해줘야한다.class Log2(models.Model): #로그 데이터 저장할 모델 #어쩌고 저쩌고 모델 내용 class Meta: app_label = &#39;postgreE&#39; ##앱 이름 정해준다. 간단한 작업이었지만 database router 라는 개념을 알게됐다. 신가하당 ㅎㅎㅎ사아즈가 큰 서비스를 만들때는 유용할 것 같다. 오늘의 공부 끝 !" }, { "title": "얼레벌레 django 따라하기 2 - db 실습 및 post 날리기", "url": "/posts/django2/", "categories": "python", "tags": "IT, 파이썬, python, django, web", "date": "2020-04-03 17:00:00 +0900", "snippet": "파이썬 웹 개발 연습차 django 로 기본 실습을 해보고자 한다 ~!!TO DO LIST 파이썬 설치 + django 라이브러리 기본 세팅 hello world ^^(get) db 연결 db 저장 요청 파라미터 값을 db 에 저장 (get) db 저장값 가져와서 출력 post 요청해보기* 실습환경은 mac os1. db 연결 및 가져와서 출력다양한 db 를 사용할 수 있겠지만 일단은 django 에서 기본 제공하는 SQLite 사용했다.프로젝트를 생성하면 기본적으로 프로젝트 폴더의 settings.py 에 SQLite 연결 세팅되어있다.DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;, &#39;NAME&#39;: os.path.join(BASE_DIR, &#39;db.sqlite3&#39;), }}기본 세팅이나 테이블 생성 같은건 튜토리얼에 너무 자세히 나와있다.여기서 중요한건 django 에서는 ORM 형태로 db작업을 한다.ORM이 뭘까여?ORM 은 object relation mapper 의 약어로 sql 문 없이 객체를 db 에 매핑시키고 조작하게 해주는 것이다. (sql 쿼리 직접 조작이 아님)장점 DB 종류에 종속적이지 않음 객체를 직관적으로 사용하기에 비즈니스 로직에 집중 가능단점 대형쿼리같은게 있으면 직접 쿼리 작성한게 아니기에 효율성이 떨어질 수 있음간단히 말하면 자바에서의 mybatis 같은 sql 쿼리 통해서 사용자가 직접 테이블 조작하는 것과는 다르게, 그 데이터가 필요한 객체를 통해 제어하는 방식이다.약간 낯설긴한데, 쓰다보면 익숙해지겠지.일단은 db에서 select 해서 데이터 가져오고, update 하는 것 해봤는데 너무 간단하다.def getAllLogs(): allLog=Log.objects.all() # sql: select * from Log for log in allLog : if (log.action == &#39;넘나리신기&#39;) : # sql: update Log set action =&#39;바꿔바꿔&#39; where action=&#39;넘나리신기&#39; log.action=&#39;바꿔바꿔&#39; log.save() print(log) # 콘솔창에 출력해보기2. 요청 파라미터 값 db 저장일단 요청 파라미터 값 가져오는 방식은 두 가지가 있다. query string url 뒤에 ~~?param=1 이런식으로 붙여서 오는 방식이다.request에서 바로 파라미터 이름으로 받을 수 있다. def param(request): action = request.GET.get(&#39;action&#39;) #~~?action=&#39;액션&#39; 이런식으로 보내면 받는다. url parameterurl 뒤에 바로 붙여서 보내는 방식이다.~/param값 이런식이다. 이럴땐, 서버 로직인 view.py 와 url 패턴 정의하는 urls.py 수정 필요하다.view.pydef urlparam(request,action): #url param 도 메소드 인자로 받는다. return HttpResponse(&quot;사용자 액션은 {} 입니다.&quot;.format(action)) #입력받은 값 바로 출력한다. urls.py path(&#39;urlparam/&amp;lt;action&amp;gt;&#39;, views.urlparam, name=&#39;urlparam&#39;),여기서 action 은 그냥 str 이기에 컨버터를 명시하지 않았다.하지만 Int 같은거는 컨버터 명시해준다. («int:num») 이런식으로요청 파라미터 가져오는 법은 배웠으니 이걸로 db 저장해본다.너무 간단하게 모델 객체 하나 만들고 입력값을 객체에 저장만 하면 된다.querystring 방식으로 해봤다.def param(request): action = request.GET.get(&#39;action&#39;) #~~?action=&#39;액션&#39; 이런식으로 보내면 받는다. log =Log(action=action) #모델 객체 만든다. action 값에 입력받은 값 넣어 초기화한다. log.save() # 객체를 db 에 저장한다. str=log.__str__() # 저장되는 내용 출력해보기 return HttpResponse(log.__str__())이렇게 하고 나면, 관리자 페이지 통해서 정상적으로 db 저장된거 볼 수 있다.ORM 방식이니까 너무 편하다. mybatis 쓸 땐, 커넥션 열고 어쩌고 쿼리 넣고 어쩌고 했는데, 그냥 코드 두 줄로 뚝딱;3. POST 로 json 데이터 보내보기 json 데이터 만들기 우선 json 데이터를 만들기 위해서는 파이썬 객체를 json 형태로 바꾸는 작업이 필요하다.json_dumps() 사용하는데, 인자로는 json 화 하고자 하는 객체, 인코딩 정보 등을 넣는다. post 보내기requests 모듈 사용하면 간단하게 보낼 수 있다. import requests 하고, requests.post 로 url, 데이터 등을 넣어서 보낸다. def sendJsonData(request): data = {&#39;logs&#39;:[{&#39;action&#39;: &#39;그냥 제이슨이양&#39;}, {&#39;action&#39;:&#39;아무거나 씁니다.&#39;}]} dataJson= json.dumps(data, ensure_ascii=False).encode(&#39;utf-8&#39;) # ensure-ascii 는 기본적으로 아스키코드로 저장되는걸 막기 위함. 기본적으로는 유니코드 str 으로 저장되서, utf-8 로 인코딩해 보낸다. headers = {&#39;Content-Type&#39;: &#39;application/json; charset=utf8&#39;} resp = requests.post(&#39;http://127.0.0.1:8000/hello/getJsonData&#39;, data = dataJson, headers=headers) return HttpResponse(resp.content) # post response 의 내용을 그대로 받아서 출력 post 로 받은 json db 에 저장하기 post 로 json을 받았으면, 문자열 형식으로 되어있으니까 다시 파이썬 객체 형식으로 json.loads 통해 만들어준다.def getJsonData(request): receivedData =json.loads(request.body) #post로 온 json 데이터 for data in receivedData[&#39;logs&#39;]: # 구조대로 for문 돌면서 저장한다. log=Log(action=data[&#39;action&#39;]) log.save()이렇게 아주 기초적인 파트를 해봤다. 하면 하는건데, 사소한 파트 (인코딩 등등) 을 몰라서 조금 삽질한 것도 있다 .낯설어서 그러지 익숙해지면 괜찮겠지 ㅎㅎㅎ일단 끝 다음엔 dbms 바꿔서 해봐야지 !" }, { "title": "얼레벌레 django 따라하기 1 - 기본 세팅과 hello world", "url": "/posts/django1-setting/", "categories": "python", "tags": "IT, 파이썬, python, django, web", "date": "2020-04-03 17:00:00 +0900", "snippet": "파이썬 웹 개발 연습차 django 로 기본 실습을 해보고자 한다 ~!!TO DO LIST 파이썬 설치 + django 라이브러리 기본 세팅 hello world ^^ (get) db 연결 db 저장 (admin페이지) 요청 파라미터 값을 db 에 저장 (get) db 저장값 가져와서 출력 post 요청해보기* 실습환경은 mac os이번 포스트에서는 기본세팅 + hello world1. 파이썬 + 가상환경 컨트롤 라이브러리 설치homebrew 이용해서 커맨드 창으로 설치했다. homebrew 설치 /usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; python3 설치 brew install python3 여기까지 설치하면 필요한 기본 설치는 끝났다. 파이썬에서는 가상 환경이라는게 있다. 여러 버전의 python 을 통해 서로 다른 프로젝트들 할때, 프로젝트 별로 환경을 따로 따서, 설정이 꼬이는걸 방지한다는데 사실 이해를 잘 못했다.그래도 또 남이 하는건 다 해보고 싶으니까 pyenv, virtualenv 설치했다. pyenv (파이썬 버전관리) brew install pyenv pyenv-virtualenv (가상환경- 프로젝트별로 따서 사용할 것) brew install pyenv-virtualenv pyenv 로 파이썬 설치 및 전역 사용 버전 정해주기 pyenv install 3.6.1pyenv global 3.6.1 프로젝트 경로에 가상환경 생성해주기 이제 실제로 프로젝트 관련 소스가 있는 경로에 가상환경을 생성해주고 활성화 한다. 프로젝트 소스 존재할 폴더 하나 만들고 그 폴더 경로해 가서 명령어 입력한다. python3 -m venv 내가사용할가상환경이름 source 내가사용할가상환경이름/bin/activate ##내 경우는 myenv 로 함 2. django 설치 및 프로젝트 생성 django 설치 pip install django 프로젝트 생성 django-admin startproject 프로젝트이름 . 여기까지 하면 기본 프로젝트는 생성이다.프로젝트를 구성하는 기본 세팅 파일들이 있고, 어플리케이션을 만들고 프로젝트에 붙여서 실제 뭔가 돌아가는걸 보는거다.즉 익숙한 스프링 프로젝트로 비유하자면 일단 프로젝트 하나 생성해서 pom.xml 같은 설정파일에 라이브러리 로딩한 정도 느낌..?기본 설정 파일 역할은 여기 에서 보고 배웠다.3. 어플리케이션 만들기 어플리케이션 생성 python manage.py startapp 어플리케이션이름 이렇게하면 프레임워크 기본 구조대로 생성된다. django 는 model, template, view 구조이다.model: db 관련된 사항으로 데이터 구조 역할이다. template : 화면단과 관련됨 (mvc 구조에서 view 느낌)view :서버 로직추가로 urls.py 파일이 있는데, 이건 dispatcher 역할을 한다. url 과 해당 url 요청 들어오면 실행해야할 메소드 짝지어준다. hello world 출력할 인덱스 페이지 url추가 어떤 url 입력 &amp;gt; Hello world 출력하도록 할 인덱스 페이지 url 추가하기어플리케이션 폴더의 url.pyurlpatterns = [ path(&#39;&#39;, views.index, name=&#39;index&#39;), ##http://127.0.0.1/어플리케이션이름 으로 접근하면, views.py 에 정의된 index 메소드 실행 ]프로젝트 폴더의 url.pyurlpatterns = [ path(&#39;hello/&#39;, include(&#39;hello.urls&#39;)), # 이 부분 추가 - hello 어플리케이션의 Url 패턴 추가해줌 hello 이부분에 본인이 정한 어플리케이션 이름 들어간다. path(&#39;admin/&#39;, admin.site.urls), # 관리자 페이지 url 로 기본 포함되어있음 ] hello world 출력할 서버 로직 view 에 추가 실제로 인덱스 페이지 url 로 요청 들어오면 응답할 서버 로직 작성from django.shortcuts import renderfrom django.http import HttpResponsedef index(request): # 리퀘스트 들어오면 응답으로 hello world 보냄 return HttpResponse(&quot;Hello, world.&quot;) 서버 띄워서 확인하기기본 구성은 다 됐다. 이제 서버를 띄우고, url 요청을 넣어서 원하는 값 반환되는지 확인한다.python manage.py runserver #서버 실행기본 세팅을 변경하기 않았다면 8000번 포트로 접근한다.http://127.0.0.1:8000/hello/짠 너무 잘됩니당" }, { "title": "쓰레드, 프로세스, 메모리 구조", "url": "/posts/process-thread-and-data/", "categories": "study", "tags": "IT, 쓰레드, 프로세스, 데이터, 힙, 스택", "date": "2020-03-28 20:23:00 +0900", "snippet": "스레드, 프로세스 etc 에 대해서 대충 이해한만큼만 정리하기.참고한 자료들은 스레드와 프로세스, 메모리구조,유튜브-스택/힙-c,유튜브-스택/힙-java 이다.1. 프로세스 시스템 자원을 할당 받는 하나의 프로그램 인스턴스 한 프로그램(실행파일)은 여러개의 프로세스로 이루어질 수도 있고, 하나의 프로세스로 이루어 질 수도 있다. 각각의 프로세스들은 시스템 자원인 메모리를 할당 받는데, 코드, 데이터, 스택, 힙 이다. 각 프로세스들은 서로 독립된 자원을 사용하고 공유하기 위해서는 서로 소통하기 위해 IPC 필요하다.2. 스레드 프로세스 내의 작업 흐름 한 프로세스 내에 여러 스레드 있을 수 있다. (멀티스레딩) 스레드는 개별적인 스택, 레지스터값을 가진다. (스택은 메모리 ram , 레지스터 값은 cpu에 별도 저장- 스레드 작업 시간 할당 받아서 작업 어디까지 했는지 기록) 힙 등의 메모리는 한 프로세스내 다른 스레드끼리 공유한다.멀티 스레딩 이란? 하나의 프로세스를 다수의 작업으로 쪼개서 여러개의 스레드가 한 프로세스 수행토록 하는 것 힙 영역, 데이터 영역 등을 같이 사용하기에 한 스레드에서 수정한걸로 다른 스레드에 반영하고 이런게 빠르다. 프로세스간 통신처럼 ipc 필요한게 아니기에 자원 낭비가 적다. 물론 다수의 스레드가 공유하는 부분에 대해서 동기화 작업에 대한 고려 필요하다. 스레드가 cpu코어 수보다 많은 스레드 실행시에는 정해진 시단 동안 번갈아가며 수행하게되고 수행 스레드가 교체될때, 각 작업을 어디까지 했고, 다음 작업에 필요한 데이터를 읽어오는 작업 (context change) 필요그럼 여기서 말하는 코드, 데이터, 스택, 힙이란?코드 실제로 기계가 해석할 수 있는 코드가 load 되는 부분. 컴파일 후 로드된다.데이터글로벌 변수나 static 변수가 저장되는 곳 프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리에서 소멸됨스택 런타임에 직접적인 할당이 되지만, 크기 같은건 컴파일시에 결정된다. 즉 할당은 dynamic이지만 크기는 static인것. 코드에서 주소로 직접 접근이 가능하다.사용이 끝나면 LIFO 로 사라진다.힙 코드에서 주소로 직접 접근이 불가한 동적 할당 영역이다.스택에 여기 접근 가능한 변수를 할당해놓고 간접적으로 접근 가능하다.c++ 에서는 포인터가 그 역할을 하고, java 에서는 new 로 객체 생성하는게 그 예이다.여기 생기는 변수는 c++ 에서 처럼 직접 해제해주던가 java 처럼 gc가 알아서 정리한다." }, { "title": "부하 테스트 작동 원리", "url": "/posts/structure-of-loadtest/", "categories": "부하테스트", "tags": "IT, 부하테스트, 구조, 작동원리", "date": "2020-03-28 20:23:00 +0900", "snippet": "일단 아주 간단하게 부하테스트가 뭐고, 어디에 사용하고 예시 grinder 동작을 잠깐 살펴봤다.근데 스터디를 들어가기 위해서는 기본적으로 동작 하는 구조를 알아야 하기에 그냥 내가 이해한대로 적어보겠다.일단 세가지 파트로 보고 내가 생각하기에 각 파트별로 필요한 기술 범위를 적어보겠다. (내 공부용이고 정확하지 않음)admin 테스트 시나리오(스크립트) 를 실행/중단 하도록 명령 내림 실제 테스트 실행 주체인 agent를 스케일링 함 (시나리오 따라서 필요한 부하만큼 조절) 시나리오 수행 모니터링 (수행이 잘 되고 있는지, 기록이 잘 되는지, 분석에 문제가 없는지 등등) 필요 기술 : 웹- view (수행 모니터링 및 명령용) 내부 (에이전트에 명령, 에이전트 증가 등 오케스트레이션 )agent 실제로 시나리오를 수행 : 시나리오는 대부분 실제 서비스에 request 날리고 response 받는 형태임 (응답시간, 정상 응답 여부 등을 로그로 기록) 시나리오 수행 결과 기록 기록한 결과를 분석하도록 전달 필요 기술: 요청 날리는건 그냥 rest 로 날릴 수 있을 것 같음 (api 부하 테스트면,,?) 근데 내가 쓰레드나 프로세스 개념이 약해서 정확히 어떻게 부하를 부여하는지 감이 잘 안잡힘analysis 기록된 결과를 받아서 용도에 맞게 분석 그래프화 햐여 보여줌 필요 기술: 로그 형태를 어떻게 분석할지 -&amp;gt; elk 같은거일단 기본 배경지식으로 공부할 거 쓰레드 로그, 로그분석 컨테이너 오케스트레이션 등 기본 개념" }, { "title": "부하 테스트 The Grinder 2", "url": "/posts/Grinder2/", "categories": "부하테스트", "tags": "IT, 부하테스트, grinder", "date": "2020-03-22 20:23:00 +0900", "snippet": "저번에는 부하테스트가 뭐고, 뭘 하고 싶은지를 보고 grinder 의 간단한 구조를 봤다.공식 사이트의 docs 를 보고 어느 정도 구조를 파악하고 대충 소스를 까봐야겠다. 어려울까봐 시작할 용기가 안나는구만 ㅎㅎ 하지만 일단 시작하자.콘솔콘솔은 사용자가 테스트 시나리오를 올리고 어떤 에이전트한테 실행하기 할지 이런 인터페이스 역할이라고 이해했다.웹 ui를 통해서 실행 상황도 보고 에이전트한테 테스트 케이스를 분배하고 실제로 일을 하는 워커를 시작하고 종료하는 등의 명령을 내릴 수 있다. default : 6373 포트 를 쓰는 http server에 올라가며 http://localhost:6373/version 이런식으로 콘솔 서비스 실행할 수 있다. 물론 포트 변경이나 GUI 사용없이 콘솔모드로만 사용도 가능하다. [공식사이트] (http://grinder.sourceforge.net/g3/console-service.html) 콘솔 서비스의 명령은 rest 방식으로 get, post, put 등을 사용하여 전달할 수 있도록 정의되어있다.콘솔 시작하기 콘솔 서비스 시작하기 콘솔 서비스 properties 세팅하기-&amp;gt; 로컬에 넣어준 properties 파일 선택하도록 설정 agent 연결하기 테스트 스크립트를 실행하라는 명령을 내려서 worker 실행하기 worker 중지하고 기록 받기Griner.console.service jar 파일을 조금 살펴보니 /~ 이런식으로 rest 쏘면 설정할 수 있도록 내부구조는 그냥 서비스에서 getmapping 이런게 되어있었다. 커스텀 하려면 이런 부분 커스텀 조금 하면 될 것 같다고 또 망상코딩하기 ㅎ.ㅎagent, worker콘솔을 통해 명령을 받거나 그렇지 않으면 grinder.properties 를 통해 정해진대로 agent 는 worker 를 통해 테스트를 수행한다.-default: 하나의 load injector machine 에 agent 하나 올려서 실행한다.agent, worker 실행 순서 agent 실행 되면 콘솔과 연결한다. 콘솔과 연결되면 콘솔의 실행 명령을 기다려서 실행하고, 그렇지 않으면 로컬에 저장되어있는 properties 를 찾아서 worker 프로세스들 띄운다. 콘솔과 연결이 끊어지거나 콘솔이 종료되면 에이전트도 종료된다. 정기적으로 다시 연결하고 수행하길 원한다면 명령어로 세팅해줘야한다.일단 간단히 공식 문서 보고 파악한 흐름이다. 대충 흐름보면 그렇구나 ^^ 하게 되는데 물론 실제로 세팅해보면 제대로 되는거 하나 없겠지 &amp;lt;font size =+3 &amp;gt;🥺🥺🥺 &amp;lt;/font&amp;gt;Grinder 로컬에서 실행해보기 공식 사이트에서 다운 받고 압축을 푼다. 압축을 풀어보면 lib에 grinder.jar 있다. java -cp ./grinder-3.11/lib/grinder.jar net.grinder.Console 로 콘솔 실행한다. 클래스 패스를 따로 잡아주면 java -cp ~ grinder.jar 파일 있는 패스 안써도 되고 java net.grinder.Console 로 실행가능하다. 나는 삽질하다가 그냥 패스 안 잡고 저렇게 실행했다. 실행하면 GUI 확인할 수 있다. agent 실행 java -cp ./grinder-3.11/lib/grinder.jar net.grinder.Grinder 하면 콘솔 명령 기다리는 에이전트 확인 가능하다여기서 스크립트 실행하는거 까지 해보려고 했는데, 잘 안되서 일단 내일 더 해봐야겠다. 진짜 어이없는 삽질했더니 너무 힘들당ㅎㅎ" }, { "title": "부하 테스트 The Grinder", "url": "/posts/Grinder/", "categories": "부하테스트", "tags": "IT, 부하테스트, grinder", "date": "2020-03-21 20:23:00 +0900", "snippet": "부하 테스트란? 🏋🏻‍♂️🏋🏻‍♂️🏋🏻‍♂️부하 테스트는 이름 그대로 정상/ 비정상적으로 많은 부하가 시스템에 가해졌을 때 시스템이 어떻게 구동될지 테스트 해보는 것이다. 목적 어플리케이션의 최대 정상 구동 허용 범위 (시스템의 케파라 불리는 것) 구성된 인프라가 어플리케이션을 서비스하는테 충분한지 더 많은 사용자 서비스 위해서 얼마나 scalable 한지 세부 목표 각 트랜잭션 발생시의 응답 시간 시스템 컴포넌트들 or DB 가 다양한 부하에 따라서 퍼포먼스가 어떻게 달라지는지 구조 설계의 결함 하드웨어 때문에 생기는 한계 (네트워크 지연 시간, cpu 한계 등등) 웹서버, 어플리케이션 서버 등의 소프트웨어 설정값들의 오류 [참고 사이트]https://stackify.com/what-is-load-testing/ https://reqtest.com/testing-blog/load-testing/ 사용되는 툴들Apahce JMeter, the Grinder 등등 이 있다.나는 사내 스터디를 하면서 the Grinder를 공부해보기로 했다.The Grinder공식 사이트에 의하면 세 가지 파트로 이루어져 있다. Worker processes 테스트 스크립트를 수행하는 파트 여러 쓰레드 통해서 병렬적으로 수행할 수 있다. Agent processes 워커 프로세스를 시작하고 멈추는 역할을 한다. 콘솔로부터 부여받은 테스트 스크립트를 워커들한테 나누어줌 The Console 프로세스들을 컨트롤하고 통계값을 취합한다.근데 뭐 말로 설명하면 너무 당연해보이지만 실제로 어떻게 구성해야할지는 해봐야알겠지.간단히 이해한 바로는 테스트 스크립트나 설정은 콘솔을 통해서만 조절하고 에이전트나 워커는 실제 테스트 하고자하는 어플리케이션의 서버에 대한건 에이젼트에 놓고 조절하는 것 같다.msa 로 비교해보면, 콘솔이 api gateway 가 될 수 있을 듯.간단히만 알아봤고 내일부터는 실제로 코드같은게 어떻게 이루어져있는지 봐야겠다." }, { "title": "실습 with spring boot Netflix OSS 4 - Ribbon", "url": "/posts/ribbon/", "categories": "msa", "tags": "IT, Spring cloud, NetflixOSS, Ribbon, Hystrix", "date": "2020-03-08 20:23:00 +0900", "snippet": "순서상 리본을 먼저하고 유레카를 했어야하는 것 같은데 어쩌다보니까 유레카를 먼저하고 유레카 없이 리본을 해보게됐다. 실습도 실습인데 블로그에 정리하는게 정말 어렵다 ㅎㅎ 제대로 이해해야 쓸 수 있는데 어렴풋하게만 이해하고 음~되네~ 하니까 정리가 잘 안된다.Ribbon이란? 👩‍🔧클라이언트 사이드에서 로드밸런싱을 할 수 있도록 해주는 넷플릭스 OSS 중 하나다.리본과 관련된 컨셉들 👇🏻👇🏻👇🏻👇🏻 List of servers: 특정 서비스를 수행하는 서버의 리스트들이다. 예를 들어서 서비스1을 호출하는 클라이언트가 있다면 서비스1을 수행하는 서버들의 리스트를 말한다. Filtered list of servers : 위에서처럼 같은 서비스를 수행하는 여러 서버들이 있지만, 서버의 상태나 물리적으로 너무 멀어서 지연시간이 생기는 경우 이 서버들을 리스트에서 제거한다. Ping : 서버가 active 상태인지 아닌지 체크하는 것이다. 기본은 유레카가 체크하도록 하지만 커스텀 할 수 있다.간단하게 Ribbon 적용해보기 🤗서비스 호출 부분1) Ribbon 디펜던시 가져오기&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-ribbon&amp;lt;/artifactId&amp;gt;&amp;lt;/dependency&amp;gt;pom.xml 에 ribbon 디펜던시를 가져오도록 작성한다. 나는 메이븐 사용해서 위와 같은 형태로 작성하였다.2) 서버리스트 추가하기위에서 말했듯이 특정 서비스를 수행하는데에는 여러 서버들이 있을 수 있고 얘네들한테 부하가 몰리지 않고 골고루 퍼지도록 하는게 부하분산(loadbalancing) 이다. 그러니까 리본이 잘 알 수 있도록 이런 서비스는 이런 서버들이 할거야 하고 알려줘야한다. 로드밸런싱을 하고자 하는 서비스를 호출하는 쪽에 서버리스트를 정의한다.ribbon: listOfServers: 127.0.0.1:8093, 127.0.0.1:8094나는 서비스 하는 어플맄이션 두 개 놓을거라 리스트에 두개 추가해줬다.앞에 해당 서비스 이름을 붙이면 서비스 별로 세팅이 가능하다는데, 일단 서비스가 하나밖에 없으니까 전체 적용되도록 서비스 이름을 안 붙였다.3)로드밸런싱 적용하기아주 간단하게 RestTemplate 사용해서 로드밸런싱 적용할 수 있다.스프링에서 제공하는 로드밸런싱기능을 사용하기 위해 @LoadBalanced 어노테이션을 붙인다.@LoadBalanced @Bean RestTemplate getRestTemplate() { return new RestTemplate(); }이렇게 하면 간단히 서비스에 적용할 이름으로 로드밸런싱 가능하다.public String callService() { String url = UriComponentsBuilder.fromHttpUrl(&quot;http://simpleRibbon/simpleRibbonEX&quot;) .build() .toUriString(); String response = restTemplate.getForObject(url, String.class);여기서 simpleRibbon 이 리본이 인식할 서비스 이름이다. 원래대로라면 127.0.0.1:8094 이런식으로 지정해주어야하지만, 리본의 로드밸런싱 룰에 따라서 서버리스트들에 있는 서버들에 알아서 로드밸런싱 해준다.서비스1) 서비스 이름 정하기 리본이 인식할 서비스의 이름을 정해주어야한다. 위에서 simpleRibbon으로 부르기로 했으니 이 이름을 서비스를 올릴 어플리케이션에 지정해주어야한다.@RibbonClient(name = &quot;simpleRibbon&quot;)이렇게 리본이 클라이언트로 인식할 이름을 지정해준다. 같은 서비스를 하는 서버리스트들에 모두 이렇게 지정해준다.이렇게 아주 간단히 리본을 적용해보았다. 이건 그냥 아무런 설정도 안 건들이고 정말 리본이 되는지 확인만 해보는 것이다.이렇게 적용하면 기본으로는 Roundrobin으로 돌아간다.다음은 리본의 세부 설정 조정을 해보겠다." }, { "title": "CDN (Contents delivery network)", "url": "/posts/cdn/", "categories": "study", "tags": "IT, Network, cdn, edge", "date": "2020-03-01 20:23:00 +0900", "snippet": "내 담당 시스템 서버는 국내에 구축되어있는데, 해외 사용자들한테서 항상 시스템이 느리다는 말을 많이 들었다. 그래서 고민했던게 CDN 이라고 들었다. 그땐 그냥 잠깐 설명듣고 음 그렇구나~ 했었는데 요즘에는 뭔가 회의도 하고 논의중인거 같아서 개념을 정리해본다.CDN (Contents Delivery Network)이름 그대로 컨텐츠와 관련이 있다.지리적으로 거리가 떨어져있는 사용자에게 컨텐츠를 더 빠르게 전달해주기위해서 엣지서버에 캐시로 저장하고 제공하는 기술이다.내가 간단히 이해한 구조로 그림을 그려봤다.국내에 서버를 두고 있는 서비스를 예시로 들었을때, 국내 사용자가 컨텐츠를 다운 받기 위해 거쳐가야하는 경로보다, 해외 사용자가 더 복잡하고 여러 단계의 경로를 거쳐야한다.따라서 해외 사용자는 컨텐츠를 다운 받을 때마다 국내에 구축되어있는 실 서버에 요청을 하고 다운 받으면 너무 오래 걸린다.이건 내가 담당하는 시스템 기준으로 이해한거고, 단점들이 또 있다. 지리적 한계에 따른 지연 : 위에 설명한 내용 서버 부하 : 서비스가 큰 경우, 사용자들이 컨텐츠 요청하고 전달하는게 시스템에 부하가 될 수 있다. 특히 특정 시간에 사용자가 몰리는 서비스 같은 경우는 더 심하다. 중간 네트워크 장애시 서비스 불가: 실서버로 연결되는 중간 네트워크에 장애 발생시 서비스 불가하다.이 문제를 해결하기 위한게 CDN 이다. 거점마다 edge 서버를 두고, 그 서버에 캐싱하여 지리적 한계를 극복하는 것.edge 서버란?네트워크 진입점을 의미하는 것으로 즉 서비스의 가장 바깥지점을 말한다. 사용자단에서 가장 가까이 있다. 요즘 그 유행하는 엣지 컴퓨팅 어쩌고도 이 엣지다…관련해서 이 사이트 가 너무 잘되어있다.CDN 을 위해서는 지리적 위치에 따라서 어떻게 가장 가까운 엣지 서버 찾을지에 대한 로직도 필요하고, 캐시 주기에 대한 고려도 필요하다.이건 나중에 추가하겠다.CDN 으로 되는 것과 안되는것CDN은 정적인 데이터를 캐싱하여 사용하는 것이다. 즉 이미지나 css 파일, html 파일 등이다. jsp 같은 프로그래밍 코드 내에서 분기를 타거나 로직에 따라서 다른 결과값이 나와야하는 것은 캐싱할 수 없다.즉, cdn 을 사용하기 위해선 web/was를 분리하듯이 프로덕트의 정적인 파트와 동적인 파트를 분리할 줄 알아야한다.그럼 CDN 은 모든 프로덕트한테 베스트 일까???물론 아니다. 간단하게 생각해보면 글로벌한 서비스를 하지 않는다면 굳이 돈도, 고려할 점도 많은 cdn을 사용할 필요가 없다. 또한 동적인 데이터가 많아서 캐싱이 크게 효과적이지 않다면 굳이 cdn을 할 필요가 있을까..?일단 여기까지" }, { "title": "실습 with spring boot Netflix OSS 3- Eureka", "url": "/posts/eurekaserver/", "categories": "msa", "tags": "IT, Spring cloud, NetflixOSS, Eureka, Hystrix", "date": "2020-03-01 20:23:00 +0900", "snippet": "풀소스는 여기 에서 확인할 수 있다.이번 실습은 Eureka 설정이다. Eureka를 간단히 말하자면 연결된 서버들의 생사 체크도 해서 레지스트리로 관리하고 서버가 죽었으면 서비스에서 제외하는 load balancing 역할을 하는 거다. 여기서 각 클라이언트들은 또 서버가 되서 다른 연결된 서버들을 클라이언트 삼을수도 있다. 링크나는 여기서 유레카 서버 하나 만들고 클라이언트 역할 하나만들어서 등록이랑 해제만 해보겠다.Eureka Server1) 일단 클라이언트들 생사체크를 하고 분산 처리를 할 서버 역할을 할 spring boot project 만든다. 여기에는 eureka-server 디펜던시를 넣어준다.&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;&amp;lt;/dependency&amp;gt;2) 서버 설정을 넣어준다.eureka.client.registerWithEureka = false // 스스로도 클라이언트처럼 등록하여 사용할 수도 있는데, 여기서는 서버로 사용할 거니까 false 로 자기자신은 등록 안하도록 한다. eureka.client.fetchRegistry = false // 클라이언트들이 레지스트리를 캐시로 사용할 수있도록 할지 선택server.port = 8761 //유레카 서버 기본 포트 3)@EnableEurekaServer 어노테이션으로 Eureka server 작동시킨다.Eureka Client클라이언트는 유레카 서버에 서비스 등록하고 싶은 어플리케이션을 말한다. eureka client 디펜던시 넣기.```xml org.springframework.cloud spring-cloud-starter-netflix-eureka-client 2. 설정 넣기. ```properties eureka.client.serviceUrl.defaultZone = http://localhost:8761/eureka // 체크될 유레카 서버 서비스 url 넣는다. 여러개 일수 있음 spring.application.name = eurekaclient // 유레카 서버에 등록될 이름 @EnableDiscoveryClient 어노테이션으로 등록여기까지 해서 두개 다 띄워보면 유레카 모니터링 화면에서 확인할 수 있다.그럼 등록까진 확인이 된다. 그냥 포트를 죽여서 서비스 해제 까지 보려고 했는데 해제가 잘 안된다.이건 내일 해봐야지. 좀 더 공식 문서도 보고 설정값도 좀 봐야겠다.Eureka client 레지스트리 등록 해제 실습어제 해보니까 클라이언트의 포트를 죽여서 아예 서비스를 내려도 eureka dashboad에서 상태가 UP 이었다. 이걸 해결하기 위해서 아래와 같은 방법들을 썼다.1) spring boot actuator 의 healthcheck 이용하여 eureka 서버 등록 해제[여기] (https://cloud.spring.io/spring-cloud-netflix/multi/multi__service_discovery_eureka_clients.html) 에 보면 자세히 나와있다. Unless specified otherwise, the Discovery Client does not propagate the current health check status of the application, per the Spring Boot Actuator. Consequently, after successful registration, Eureka always announces that the application is in ‘UP’ state. This behavior can be altered by enabling Eureka health checks, which results in propagating application status to Eureka.그래서 해답은 클라이언트 설정에 eureka.client.healthcheck.enabled: true 를 추가하는 것이다. 나는 클라이언트에 @EnableDiscoveryClient 이걸 넣으면 자동으로 체크해주는 알았더니, 현재 어플리케이션 클라이언트의 상태를 서버에 리프레시 안해줘서 정상 등록된 이후에는 서버에서 볼땐 클라이언트의 상태가 UP 에서 변하지 않았다.근데도 잘 이해가 안가서 조금 더 찾아봤다. 애초에 쓰는 이유가 자동으로 hearbeat 날려서 죽은 놈은 뺀다는거 아니었어…?이 페이지 를 참고해보면 Spring boot 의 actuator 의 healthcheck를 유레카 서버에 반영하겠다는 뜻으로 하는 설정이다. Additionally it turns out that the default statuses defined by Actuator and Eureka matches each other perfectly, so everything that needs to be done is to determine current aggregated application status, map it to Eureka’s and return it.2) 클라이언트 등록 해제 판단 기준 아주 짧게 하기 이것 저것 설정을 찾아보니, 클라이언트 등록 해제하는 기준때문일 수도 있겠다는 생각을 했다. “나 살아있어요~~” 하고 heartbeat을 보내는데, 일정 기간 동안 이걸 안보내면 서버 레지스트리에서 삭제한다. 서버로 heartbeat 보내는 주기 : eureka.instance.lease-renewal-interval-in-seconds = 30 (기본 30초) 서버에서 일정 시간 이상 연락 없으면 클라이언트 죽었다고 판단하는 시간 : eureka.instance.lease-expiration-duration-in-seconds =90 (기본 90초)그래서 eureka.instance.lease-renewal-interval-in-seconds =1eureka.instance.lease-expiration-duration-in-seconds =2 로 확 줄였다.일단은 혼자해보는거니까 확 줄였는데 여기 나 여러군데 글을 읽으니 이 값을 조정하는건 기본 설정값을 디폴트로하고 짜여진 클라이언트 관리 주기 같은 것 때문에 비추라고 하네.일단은 여기까지 살펴봤고 실습은 했다. 아무래도 설정값도 더 공부해보고 여러 클라이언트 만들어보고 돌려봐야겠다." }, { "title": "SSL offload 란..?", "url": "/posts/ssloffload/", "categories": "study", "tags": "IT, Network, ssloffload", "date": "2020-03-01 20:23:00 +0900", "snippet": "요즘은 부하분산의 중요성을 많이 느낀다.물론 고리쩍부터 중요했겠지만 나한텐 이제야 와닿았잖아요..?이번에 네트워크 작업을 하면서 ssl offload 작업을 했다.ssl offload 는 단순히 말하자면 외부 -&amp;gt; L7 -&amp;gt; 내부 로 두 번의 연결과정에서 모두 ssl 인증 거치는데 발생한느 부하를 줄이고자 외부 -&amp;gt; L7 에서만 ssl 인증을 한다.출처-각각의 웹서버는 ssl 인증 과정을 수행하지 않고 그 과정을 앞단에서 맡아서 해주길 바라는 거다." }, { "title": "SNAT 과 DNAT", "url": "/posts/snatdnat/", "categories": "study", "tags": "IT, Network, NAT, SNAT, DNAT", "date": "2020-03-01 20:23:00 +0900", "snippet": "네트워크 공부는 끝이 없다. 기본 지식이 없으니까 나는 공부할 게 넘쳐난다네~~~~ 팀 업무 중에는 네트웍 작업을 하면 서비스 체크를 해야하는데 진땀 한번 뺐다 ㅠ 지난 주말에 서비스 체크를 하는데 잘 되던 기능이 안되는거 아닌가..?그래서 여기저기 물어서 찾아보니까 네트워크 작업을 하면서 SNAT 으로 작동해서 내 서비스의 아이피를 연동 시스템에서 인식을 못해서 문제라네… 부장님들이 해결책을 알려줬는데 도대체 어떻게 접근해서 해결하는지 알아듣기 위해서는 내가 공부를 해야지.NAT 이란..?간단히 말하면 같은 네트워크 내의 여러 아이피들이 하나의 대표 아이피로 소통하는 것이다. Network Address Translation 의 줄임말.여러가지 장점이 있지만 사내 내부망 같은 경우 같은 네트워크 임을 관리 하기 위함으로 사용되기도 한다.SNATSource NAT 이란 뜻으로 패킷의 출발지 주소를 변경한다. 잘 와닿지 않아서 그림으로 그려봤다.여러 요청들이 들어와도 내부망으로 들어올땐 SNAT 때문에 요청 패킷의 소스 ip 가 모두 같게 들어온다.여기서 문제는 L4 를 통해 내부망의 서버가 다른 내부망 내 서버에 요청을 하면, 요청은 SNAT 된 ip 로 갈아 끼게 되고 내부망 내의 ip로 인증 예외 처리를 설정에 명시해 놓은 경우, 설정 예외된 ip 로 요청이 오는게 아니니까 예외가 안된다.그렇다고 해서 SNAT ip 를 다 인증 예외 처리하기엔 외부에서 들어오는 요청이 모두 같은 ip 로 갈아껴서 들어가는데 모두 예외처리 해주는 것과 같아서 문제가 되었던것.내 서비스 같은 경우는 호스트 파일에 내부 서버 ip 를 특정하여 L4서버 안 타게 만들어서 해결했었다.DNATDNAT 은 반대로 패킷의 목적이 ip 를 갈아껴준다. 외부 사용자가 요청을 할때는 외부에 공인된 ip 를 가지고 요청을 할텐데 이걸 가지고 내부의 리얼 서버 ip 로 변경해주는 작업이다. 로드 밸런서가 하는 역할이라고 할 수 있다." }, { "title": "MAC 에서 포트 죽이기 !", "url": "/posts/port-kill-in-mac/", "categories": "기타", "tags": "IT, MAC, MACBOOK, 맥북, 포트, pid", "date": "2020-02-29 19:00:00 +0900", "snippet": "내 인생 최초로 맥북을 사서 사용하려니까 이것저것 외워야 할 단축키며 명령어가 너무 많다 ^^ 나 요즘 완전 인간 고라파덕 ^^….너무 간단하지만 몰라서 찾아봤던것중에 하나는 포트 죽이기다.스프링 부트 실습하는데 자꾸 포트 사용중이라고 하니까..ㅎㅎ..커맨드창에서 1) lsof -i : 포트번호2) kill -9 pid 번호 하면 된다." }, { "title": "실습 with spring boot Netflix OSS 공공api 2 - Hystrix circuit breaker", "url": "/posts/hystrix-2/", "categories": "msa", "tags": "MSA, Spring cloud, Netflix oss, zuul, IT", "date": "2020-02-28 15:34:00 +0900", "snippet": "풀소스는 여기 에서 확인할 수 있다. circuit open 실습은 전 소스 + 아주 조금 수정으로 간단히 해볼 수 있다.1) 우선 @EnableHystrix -&amp;gt; @EnableCircuitBreaker 로 바꾼다.@EnableCircuitBreaker //circuit breaker@Service public class searchService {2) circuit breaker 지정할 메소드에 에러통계를 낼 묶음인 commandkey , 각종 세팅 적는다. @HystrixCommand(fallbackMethod = &quot;fallback&quot; , commandKey = &quot;askLastTm&quot;,commandProperties = { @HystrixProperty(name = &quot;circuitBreaker.requestVolumeThreshold&quot;, value = &quot;5&quot;), @HystrixProperty(name = &quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value = &quot;10000&quot;) }) public String askIsOver(String apiAddr, String strsch) throws Exception {여기서는 솔직히 한 메소드 가지고 실패내고 오픈되는것만 볼꺼니까 커맨드키 지정없어도 잘되지만, 그냥 지정했다.그리고 HystrixProperty 는 굉장히 여러개 있는데, 여기서 정의한 것들은 requestVolumeThreshold, sleepWindowInMilliseconds이다.requestVolumeThreshold : circuitbreaker 작동위한 최소 요청 갯수. 10초에 20개가 기본이라 5개로 줄였다.sleepWindowInMilliseconds : circuit open 지속시간이다. 기본이 5초 여서 10초로 늘렸다.여기서 @HystrixProperty 어노테이션이 안 먹히는 문제가 있었는데, 이건 autoimport 가 안되고 링크 에서 본대로 수동으로 import 시켜줘야했다.이렇게 기본 세팅을 하고 간단하게 일부러 오류를 발생시켜서 circuit 을 오픈시키기 위해 소스 수정을 조금 했다.@GetMapping(&quot;/start/{apiAddr}/{strsch}&quot;) @ResponseBody public String searchDest(@PathVariable String apiAddr, @PathVariable String strsch) throws Exception { return searchService.askIsOver(apiAddr,strsch); //getBusRouteList/153 이런꼴 }api 명을 틀리게 한다던지, 검색 값을 없앤다던지 해서 오류를 유발하고자 get 으로 요청할때 uri 에 값을 명시하도록 했다.@GetMapping(&quot;/start/{apiAddr}/{strsch}&quot;) @ResponseBody public String searchDest(@PathVariable String apiAddr, @PathVariable String strsch) throws Exception { return searchService.askIsOver(apiAddr,strsch); //getBusRouteList/153 이런꼴 }이걸 통해 postman으로 계속 틀리게 쏜다음에 제대로 쏴도 fallback으로 바로 빠지는지 확인해보았다. 정상적으로 쏴도 circuit open 후 이기에 실행도 되지않고 바로 fallback 실행하는 모습이다.여기까지는 아주 간단히 확인할 수 있다 :)" }, { "title": "실습 with spring boot Netflix OSS 공공api 1 - Hystrix fallback", "url": "/posts/hystrix-1/", "categories": "msa", "tags": "MSA, Spring cloud, Netflix oss, zuul, IT", "date": "2020-02-28 15:34:00 +0900", "snippet": "풀소스는 여기 에서 확인할 수 있다.아주 기본적으로 짜서 돌아는 가는걸 확인하려고 한다. 첫번째로는 가장 간단해보이는 특정 요청 실패시 fallback 메소드 실행이다.정말 간단하게 해보고자 나는 컨트롤러 , 서비스 하나씩만 만들고 공공 api 사용해서 정상 응답일때/ fallback 일때를 보여주기로 했다 :)사용한 공공 api 노선정보조회 서비스 요청 데이터 : 노선 번호 응답 데이터 : 시/종점, 첫차 시간, 막차 시간, 노선 id 등 (xml 형식)일단은 get 으로 요청 들어오면 공공 api 사용해서 해당 노선의 막차시간을 표기하도록 한다. 노선 번호는 입력받고 싶었는데 귀찮아서 그냥 내가 자주 타는 153번으로 고정했다. 구조는 간단하다.그리고 구현도 그냥 resttemplate 통해서 간단하게 만들었다.나중에 재활용해서 확장해보려고 resttemplate 은 팩토리로 만들어서 주입해서 쓰고, DAO로 busInfo 라는 클래스 만들었다.여기까지는 스프링 기초를 가지고 쉽게 구현할 수 있다. 이 상태에서도 만약 공공 api 응답 받아올때 에러가 난다면 try catch 로 막을 수는 있다. public String askIsOver() throws Exception { String baseUrl = &quot;http://ws.bus.go.k2r/api/rest/busRouteInfo/getBusRouteList&quot;; String serviceKey = URLDecoder.decode(&quot;api 인증키 자리&quot;, &quot;UTF-8&quot;); // 이거 안해주면 인증 에러 남. 한번 더 인코딩 하면서 인증키가 제대로 전달안됨. UriComponents uri = UriComponentsBuilder.fromHttpUrl(baseUrl+&quot;?&quot;+&quot;serviceKey=&quot;+serviceKey+&quot;&amp;amp;strSrch=153&quot;).build(); RestTemplate restTemplate = rest.restTemplate(); try { String apiResult = restTemplate.getForObject(uri.toString(), String.class); //응답이 xml 로 와서 잘라서 DAO인 busInfo 에 넣는다. DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder dBuilder = dbFactory.newDocumentBuilder(); Document doc = dBuilder.parse(new InputSource(new StringReader(apiResult))); doc.getDocumentElement().normalize(); Node firstResult = doc.getElementsByTagName(&quot;itemList&quot;).item(0); // 일단은 막차시간 정보만 뽑아서 저장 for (int temp = 0; temp &amp;lt; firstResult.getChildNodes().getLength(); temp++) { String nodeName =firstResult.getChildNodes().item(temp).getNodeName(); if(nodeName.equals(&quot;lastBusTm&quot;)) { busInfo.setLastBusTm(firstResult.getChildNodes().item(temp).getTextContent()); } } return busInfo.getLastBusTm(); //정상이면 막차시간 리턴 }catch(Exception e) { e.printStackTrace(); }finally { return &quot;트라이 캐치입니다&quot;; // try catch finally 로 에러 막음 } }하지만 여기서는 hystrix 사용해 간단하게 fallback 메소드를 실행해버리겠다. hystrix 사용하게 위해서는 세가지 단계가 필요하다.1) pom.xml 에 의존성 정의해줘서 메이븐이 읽어오게 하기 ! &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt;2) @EnableHystrix 어노테이션 붙여주기이건 메인 메소드가 있는 위치에서 어노테이션 붙여줘도 되고, 지금은 circuit 같은 넓은 단위 봐야하는 거 안쓰고 fallback 만 해볼거니까 해당 메소드가 있는 서비스에다가만 붙여줘도 정상 동작한다. 나중에 circuit open까지 해볼꺼니가 메인 메소드 있는데에 붙여준다. @EnableHystrix // 여기 이 어노테이션 ! @SpringBootApplicationpublic class SnoopyApplication { public static void main(String[] args) { SpringApplication.run(SnoopyApplication.class, args); }}3) @HystrixCommand(fallbackMethod = “fallback메소드 이름”) 로 fallback 메소드 실행할 위치 정하고, 메소드 내용 정의하기 @HystrixCommand(fallbackMethod = &quot;fallback&quot;) // fallback 일 경우 fallback이란 이름의 메소드 실행 public String askIsOver() throws Exception { ... } public String fallback() { return &quot;노선 정보가 없습니다.&quot;;}이렇게 하면 일부러 url을 잘못 넣었을 때에도 fallback 메소드 바로 실행된다 :)근데 이렇게 실습을 하나 해보니까 궁금한 점이 있다.try catch 와 fallback 메소드의 차이점try catch 를 하는 경우 exception 발생하면 메시지를 찍어보니까 콘솔로그로 왜 에러가 났는지 파악하기가 쉽다.반면에 fallback 메소드로 빠지는 경우 에러로그가 남지 않기 때문에 무엇때문에 난 에러인지 찾기가 어렵다.stackvoerflow 를 좀 찾아보니 같은 문제로 고민하는 사람들이 있었다. 링크링크에서 처럼 throwable 인자를 추가해서 에러 로그 확인해보았다.😋😋😋 에러 추적을 쉽게하기 위해서는 fallback 메서드에 throwable 인자를 추가하자 ^^ !! public String fallback(Throwable e) { e.printStackTrace(); return &quot;노선 정보가 없습니다.&quot;;}fallback 실습 끝 !! 다음은 circuit open 실습 해보겠습니다~~" }, { "title": "MSA 공부 시작 - 11번가 spring cloud 기반 MSA 로의 전환 정리", "url": "/posts/MSA-study1/", "categories": "msa", "tags": "MSA, Spring cloud, Netflix oss, zuul, IT", "date": "2020-02-22 15:34:00 +0900", "snippet": "이번에 회사사람들과 MSA 관련 스터디를 하기로 했다.첫번째로는 이 영상 을 보고 얘기를 나눠 보기로 했다. 영상을 보고 정리 겸 올려본다.1) 모놀리식 시스템 vs MSA모놀리식 시스템은 시스템 구성 요소들이 하나로 통으로 돌아가는 것이다. 당연하게도 MSA 는 요소요소들을 하나씩 쪼개서 분리해놓은 것이고..출처- Introduction to Monolithic Architecture and MicroServices Architecture이게 약간 “음 그렇지~~” 싶은 말이긴 한데 정확히 감이 안온다. 내가 이해하기로는 MSA 구조에서는 사용자 인터페이스 이후의 기능별로 서비스 코드 구성이나 db 를 분리해놓고 사용한다는 것 같다.그럼 뭐가 좋길래 그렇게 쓸까?? 큰 서비스를 개발/운영할때 부담감이 적다. 개개별 파트가 잘못되면 다른 서비스까지 안되는 상황을 막을 수 있어서. 새로운 기술을 받아들이기 쉽다. 기존 있는 파트에 영향없이 새 파트에만 새로운 기술 사용해볼 수 있으니까단점은 서비스간 디펜던시가 있는 경우 구조 구성하는게 까다롭다는점…? 사실 단점은 크게 다가오지 않는다. 장점이야 현재 모놀리식 어플리케이션을 운영중이니까 와닿는데 단점은 글쎄 ^^ …2) 서버 분리를 어떻게 해야하지??기존의 레거시와 같이 진행해나가는 방식 = hybrid 아무래도 기존 레거시 시스템이 너무 크면 당연히 작은 파트부터 해보는 하이브리드일 수 밖에요 ^^…3) 사용한 툴= Netflix OSS (open source software) + spring bootNetflix OSS 가 제공하는 세가지 툴1) Hystrix : 라이브러린데 장애 전파 방지 /resilience (장애가 나도 다시 회복되도록 하는것)장점 -&amp;gt; java vm 만 있으면 그냥 상속받아서 사용할 수 있음 or 어노테이션/ 스프링의 디펜던시로 바로 적용 가능hystrix 4가지 기능thread isolation 메소드를 인터셉트하여 대신 실행한다. 여기서 설정값이 semaphore or thread 중 선택한다. semaphore 는 메소드 실행하는 스레드를 분리하지 않는 대신에 스레드를 몇개씩 부여받아서 해당 개수 이상 요청 실행해야하면 fallback 이 일어난다. thread 는 메인 스레드와 메소드 실행 스레드를 분리한다. 스위칭이 많은 경우 context 공유 에 있어서 이슈가 있을 수 있다. 관련 내용circuit breaker 메소드 실행 성공/실패 발생 여부로 통계 기록하고 circuit open 여부 결정 실패할 경우 사용자가 제공한 메소드 대신 실행한다 (fallback) 특정시간 동안 종료 안되면 exception (timeout) time out 기능 특별한 이유 = socket timeout 이런건 내가 원하는대로 실행되지 않고 너무 많은 레이어에서 timeout 설정 얽혀서 복잡해!그럼 circuit open 이 무슨 뜻이지? 일정 시간동안 일정개수 호출 통계 &amp;gt; 일정 비율 이상 에러나면 circuit open 한다. -&amp;gt;이러면 메소드 호출해도 바로 exception 으로 튕겨버린다. A -&amp;gt; B,c,d 서버 호출할때 B 만 안되면 B 만 막는다. 다시 닫히는 시점은 일정시간 경과후에 단한번 시도해서 되면 이때 서킷 닫는다.—&amp;gt; 기본 설정: 10초간 20개 이상 호출 발생, 50% 이상 에러면 5초간 서킷 오픈서킷 통계내는 단위는 commandKey 로 선언해서 묶을 수 있다. -&amp;gt; 너무 작은단위로하면 기간 초동안 횟수 범위 안넘어서 안잡힐 수 있다.Fallback은 서킷 오픈뿐아니라 timeout 등 어떤 종류의 exception 발생하면 무조건 난다. 그냥 어노테이션으로 메소드 이름 지정해놓고 정의해놓는다.😈 HystrixBadRequestException 😈 파라미터를 잘못 넘기거나 사용자가 call 할때 오류가 나는 건 이걸로 처리해야한다. -&amp;gt; 서버의 에러가 아니라 사용자 에러니까 카운트 오류 방지하기 위해서 이걸로 처리해야함Timeout 은 서킷브레이커 단위로 할 수 있고 기본 시간이 너무 짧다.Ribbon로드발란싱하는 라이브러리 로드발란싱을 어플리케이션이 함으로써 L4 같은 하드웨어에 집착하던 것 더이상은 No….. 나중에 eureka 와 합쳐져서 굴러가는거 설명합니당EurekaDNS 기반이 아니라 서버가 자기 이름+ ip + port 등록하고 조회 서버 시작할때 유레카 서버에 자동으로 자신이 살아있다고 등록 지속적으로 서비스 체크를 해서 유레카 서버는 해당 리스트를 갱신한다. (다운되면 알아서 뺌) Eureka + Ribbon 이면 서버 목록 이런거 직접 ribbon 에 등록할 필욯없어서 eureka 가 서버 목록 가져오고 알아서 살아있는지 체크하니까 복잡한 절차 없이 가능하다.zuul API GATEWAY hystrix + ribbon + Eureka 섞여 있어서 채택함 zuul 에서는 기본 thread isolation 이 semaphore 이다.configuration server모든 서버에 컨피크 클라이언트 탑재하고 있어서 서버 시작할때 자동으로 각 서버의 컨피그 안에 들어가게 된다.개개별 서버에 설정 배포할 필요없고 편리하다.모니터링서버간 trace 정보 전달은 http header 같은 프로토콜 헤더로 전달되는데 스레드가 바뀌면 컨텍스트 유지가 어렵다.Spring cloud sleuth 라는게 있는데 호출시마다 trace 정보를 생성하고 log 에 남기거나 수집서버 (zipkin) 으로 전달해준다. db 호출 구간은 이걸로 아노디서 spring AOP 사용해 sleuth api 를 인젝션 해줘서 정보 직접 생성한다.소감흠 내용이 어렵긴 한데 그냥 그런가보다 하게 된다.아무래도 코드단으로 직접 만져본적이 없어서 대충 알겠다고 생각하는 거 같은데 하나도 모르는거겠지 😉내가 허접임을 인정하고 앞으로 배워나가면 된다!!코드를 좀 더 많이 만져봐야겠다. 눈으로만 보니까 자꾸 알고 있는거 같다." }, { "title": "19-12-03 이 주의 테크 고민거리- 스마트시티와 개인정보 침해", "url": "/posts/topic-of-this-week-1203/", "categories": "news", "tags": "공부, 테크기사, 테크, tech, technology-of-the-week, 고민거리, 스마트시티, 개인정보침해", "date": "2019-12-03 14:24:00 +0900", "snippet": "주에 한 번 정도 최신 테크 기사를 몇개 읽고 시사점에 대해 생각 정리를 해봐야겠다. 주로 관심있는 분야에 대해서 할거니까 스마트시티나 3d map 관련된 기사로 준비해야지.:: 19/12/03 이 주의 테크 고민거리 - 스마트시티와 개인정보침해1) 포브스 기사 - How Data Will Fuel Smart Cities 기사 세줄 요약 ! ! 스마트 시티 시범 운영중인 곳들을 보니, 여기서 대용량 데이터 수집해서 분석하니 자원이 얼만큼 필요한지 예측하는 것뿐만 아니라 사용 패턴을 분석하여 더 많은 방법으로 활용할 수 있다. 수집된 데이터의 ownership을 누가 가져가느냐에 대한 의견분쟁들이 있지만 sidewalk 에서 토론토랑 협약 맺어서 하는 시범 사업에서는 여기서 수집하는 데이터를 공공 자산으로 삼겠다는 조항이 들어있다. 지금은 이런 데이터들과 이를 사용하는 기술들의 진보로 스마트 시티를 실현화하는 성장 변곡점이다.     엄청나게 오바를 하면서 마치 스마트폰 나오기 직전 마냥, 스마트 시티 실현 직전인 것 같이 말하네 ㅎㅎ. 이 기사에서는 스마트 시티를 현실화하는데는 다양하고 방대한 데이터 수집이 가장 큰 역할을 한다고 말한다. 물론 나도 공감한다. 데이터가 늘어나고 다양한 분야에서 이 데이터를 활용할 수 있다면 그렇게 난리치는 커넥티비티 어쩌구 이런거 아닌가.    하지만 여기서는 수집된 데이터를 공공 자산으로 협약한 sidewalk-토론토의 예시로 개인정보침해에 대한 의견은 스무스하게 넘어간 경향이 있다. 나도 예전엔 기술의 발전은 곧 나의 편의성 증대로 이어질테니까 내 정보를 수집하는데 크게 거부감이 없었다. 하지만 요즘은 무슨 앱 하나만 깔려고 해도 도저히 어디에 사용될지도 모르는 정보 수집 권한이 필요하고, 나를 타켓팅한 맞춤 광고들은 편리를 넘어서 공포스러울 정도다.    기술의 발전을 위해서 어디까지 개인정보를 제공해야하는가, 어느 선까지 공공을 위한 정보 제공이라고 볼 수 있는지 기준을 마련해야할 것 같다. 나라별, 주 별로 다른 기준을 가지고 있다고 한다면 그게 진정한 기술 발전에 도움이 되는 데이터라고 할 수 있을까? 그렇다면 하나의 통일된 기준 규격을 위해서는 어떤 토론이 필요하고 어떤 단체가 주관하는걸까 궁금해졌다. 분명히 논의를 안하는건 아닐텐데…. 말로만 관심있다고 해왔지만 실체화되기 위한 준비 단계들에는 관심을 가지지 않았었네. 이런 기사들을 찾아 읽어봐야겠다.2)Quartz 기사 Smart cities will always have a data privacy problem 기사 요약 !! 스마트시티에는 데이터 수집이 중요한데, 여기에는 프라이버시 침해에 대한 의견분쟁이 있다. (Privacy paranoia, or surveillance capitalism?) 도시 생활하면서 수집되는 정보는 앱처럼 특정 부분은 정보제공 동의하고 말고 선택하기 어렵기에 합의점을 찾기 더 어려운 문제다. 그렇다고 특정인 지목할 수 있는 정보 지우면 활용 데이터가 손상된다. 현재 법령들은 기술 발전 이전의 항목들이기에 조정될 필요가 있고, 여기에는 시민들의 참여가 필요하다.     이 기사에서는 데이터 수집시 프라이버시 침해에 대해서, 시민의 참여와 토론의 중요성을 강조하고 있다. 현실적으로 고민해봐야할 문제임은 분명하고 토론토에서의 프로젝트처럼 새로운 길을 열어가는 기업, 정부, 도시 시민들이 어떻게 합의점을 찾을지가 중요하겠지.     이런 기사를 읽으면 토론토 시민들이 부러워지기도 하지만, 서울에서 일어나는 변화들에 대해서 내가 무관심했다는 사실을 깨닫는다. 분명히 서울에서도 정보 수집을 통해 도시 적용할 솔루션을 열심히 만들고 있을텐데 너무 무관심했다. 멀리 있는 사례만 바라보지 말고 주변을 좀 살펴야겠다.     오늘의 반성 끝 !! 😥" }, { "title": "SSL 인증", "url": "/posts/ssl-certification/", "categories": "기타", "tags": "공부, SSL, CA, 인증, 대칭키, 공개키", "date": "2019-12-01 21:36:00 +0900", "snippet": "    회사 내부 시스템 운영하는 일을 하다보니, 처음 세팅할때 인증서 오류 관련된 내용을 자주 접한다.SSL 인증에 대해서 정리하고 넘어가야징ㅎㅎㅎ 참고SSL 은 프로토콜 이름, Https 는 SSL 프로토콜 위에 돌아가는 프로토콜SSL 인증서는 두 가지 기능을 한다. 클라이언트가 연결하려는 서버가 클라이언트가 맞는지 인증 클라이언트 - 서버간 통신에 사용하기 위한 대칭키를 제공처음 개념을 들으면 무슨 말인지 모를 수 있다. 요약해서 말하자면 SSL 인증서는 대칭키 방식, 공개키 방식 두 가지 인증 방식을 사용한다. 공개키 방식은 서버를 인증하고 대칭키를 전달하기 위해 사용하고, 대칭키는 서버-클라이언트간 실질적인 통신을 위해 사용한다.공개키 방식을 사용하는 이유는 대칭키를 보안속에 전달하기 위함이고, 실질적인 통신은 대칭키를 하는 이유는 공개키 방식만으로 하는것이 너무 부하가 많이 가는 일이기 때문이다.    일단 요약은 했고, 그럼 공개키 방식, 대칭키 방식은 무엇인지부터 ssl 인증이 어떤 방식으로 서버-클라이언트 연결되는지 알아보자.공개키 방식    통신하고자 하는 A,B 가 있을 때, A는 공개키로 데이터를 암호화하여 전달한다. 이 내용은 B가 가지고 있는 비공개키를 통해서만 복호화 될 수 있다. 따라서 C 가 공개키를 안다고 하더라도 복호화할 수 없다.이 방식을 역으로 사용하여 상대를 인증할 수 있다. A 가 비공개키로 데이터 암호화해서 전달한다고 생각해보자. 그럼 B는 공개키로 복호화하는데, 이게 복호화가 된다는 것은 A가 해당 비공개키로 암호화한다는 것을 인증해준다. 이것을 전자서명이라고 한다. 이때 공개키가 털린다면 해당 데이터가 위험하다는 단점이 있지만, 데이터 암호화 보다 서로간의 인증을 위한 역할이기에 이 방식 사용한다.:thinking: SSL 인증서에서는 공개키 방식 어떻게 사용하지?     SSL 인증서를 발급해주는 CA 기관이 있다. 브라우저는 CA 에서 발급해주는 인증된 리스트를 가지고 있다. 서버 접근하면 서버는 인증서를 주는데, 이때 브라우저는 가지고 있는 인증 CA 에서 발급했는지 보고 CA 의 공개키로 복호화 한다. 여기서 복호화가 된다면 전자서명으로 CA 의 인증이 된 믿을만한 인증서, 서버구나 확인이 가능하다.대칭키 방식    통신하고자하는 A, B 가 서로 같은 키를 가지고 암복호화 하는 것이다. 이때는 처음 통신할때 대칭키를 나누어 가지는 것이 관건이다. 여기서 탈취되면 다 끝이니까 ㅠㅠ .:thinking: 대칭키 어떻게 나누어 가지지?    클라이언트는 위의 방식을 통해 얻은 서버의 공개키로, 서버에서 보낸 랜덤 데이터와 자기가 생성한 랜덤데이터를 암호화해서 pre_master를 전달한다. 같이 공유한 pre_master 값을 조작해서 대칭키를 만든다." }, { "title": "L4 와 L7 차이점", "url": "/posts/what-is-difference-between-l4-l7/", "categories": "study", "tags": "공부, 네트워크, l4, l7", "date": "2019-12-01 14:24:00 +0900", "snippet": "네트워크 관련된 문제를 마주할때마다 늘 나오는 단어들이 있다.L7, L4 ! 솔직히 어렴풋이는 알지만 너무 헷갈려. 이해했다가도 돌아서면 까먹는다.그래서 정리를 한번 해봐야지. 🤠:baby: L4, L7 이 뭔데?    L 은 loadbalancer 를 뜻한다. 서버의 부하를 분산시키기위해서 여러대의 서버를 두고 그 서버들한테 어떻게 연결시켜줄지 관리해주는 역할을 말한다. 그렇다면 뒤에 붙은 숫자는 뭘까?일단은 이걸 이해하기 전에, OSI 7계층을 먼저 봐야한다.저 뒤의 숫자 4, 7 이런건 7계층 중 어느 단계인가를 나타낸다.:relaxed: L4, L7 은 부하분산해주는 시점이 다른 거구나L4 : trasport layer 단에서 조정 &amp;gt; IP +port 를 보고 조정 (TCP/UDP 프로토콜)여기서 분산처리 위해 VIP (virtual IP) 사용한다. 일단 실제 서버로의 요청을 VIP 로 보내면 안에서 내부 로직으로 분산 처리해준다. L7 : application layer 단에서 조정 &amp;gt; 최상단이기에 ip+port+페이로드까지 전부 볼 수 있다. (HTTP 단까지)    L7 은 L4 보다 상단 영역이기에 L4 의 역할도 수행할 수 있다. 그리고 L7 은 페이로드에서 URL 까지 볼 수 있기에 조금 더 상세한 분산처리가능하다.로드밸런서의 알고리즘 종류는 자세히 정리된 다른 블로그 참조 ! !" }, { "title": "WIN10 환경에서 갑자기 cpu 100 칠때 해결법", "url": "/posts/win10-cpu-error/", "categories": "기타", "tags": "공부, win10, cpu점유율", "date": "2019-11-28 17:36:00 +0900", "snippet": "사람살려,,,, 출근해서 평화롭게 일하려고 하는데, 갑자기 컴퓨터가 버벅거리기 시작했다.바로 작업 관리자로 메모리 확인해보니까, cpu 100..??? cpu 제일 많이 잡아먹고 있는 프로세스 보니까 가장 많이 잡아먹는건 system이었다.. 그걸 멈출 순 없잖아요 :thinking:시도해본 해결 방안들 🐱‍👓 windows 색인 중지CPU 부하 줄이는 방법 블로그 글들마다 제일 처음으로 소개하는 방법이길래 따라했다.실행 - services.msc &amp;gt; windows search 기능 종료나름 줄어들긴했는데 그래도 여전히 cpu 70~80 ㅠㅠ windows 구성 요소 저장소 파일 손상 확인찾아보니 win10 에서 드라이버 업데이트 과정에서 이런 상황 겪는 사용자들이 많았다.시스템 파일에 문제있는지 탐색하고 복구 진행하는 과정으로 해결.1) cmd 창에 Dism /online /cleanup-image /restorehealth 입력 2) 검사 완료 후 sfc /scannow 입력 !!확실히 뭔가 문제가 있었는지, 복구 완료 메시지가 떴고, 재부팅하니 cpu 5 정도로 회복이 됐다 👏🎉👏🎉✨ 아니, ms 무슨 일배포를 8만건 한다는디 이렇게 불안정해도 되는건가 싶긴한데.. 그래도 행복하다면 ok 입니다. 👌" }, { "title": "Matplot 에서 한글 폰트 적용하는 법", "url": "/posts/how-to-use-Korean-matplot/", "categories": "python", "tags": "공부", "date": "2019-11-08 17:36:00 +0900", "snippet": "matplot 에서 한글 폰트를 적용하지 않으면, 축의 한글이 깨진다. ㅠ이를 해결하는 방법 :thinking:matplotlib 의rc paramater 설정으로 전체 그래프에 적용한다.1) matplotlib 캐싱 폰트 리스트들에 내가 바꾸고자 하는 한글파일이 캐싱되어있는지 확인한다.import matplotlib as mplimport matplotlib.pyplot as pltprint(&#39;matplot 캐시 폴더&#39;,mpl.get_cachedir()) //matplot 캐시 폴더&amp;gt;&amp;gt; matplot 캐시 리스트 C:\\Users\\Admin\\.matplotlib2) 캐싱되어있지 않다면 폰트 설치 후 jupyter 재시작하고 폰트리스트 json 캐싱 확인3) rc parameter 에 font-family 지정plt.rcParams[&quot;font.family&quot;] = &#39;NanumGothicOTF&#39; //fontlist.json 에 캐싱된 한글 폰트 mpl.rcParams[&#39;axes.unicode_minus&#39;] = False //마이너스 축 안깨지게 하기 " }, { "title": "JSP 란?", "url": "/posts/what-is-jsp/", "categories": "study", "tags": "공부", "date": "2019-10-26 17:36:00 +0900", "snippet": ":thinking: 도대체 JSP 가 뭘까 ?    웹을 배우면서 자주 접하는 jsp지만 정확히 어떤 역할을 하고 왜 사용하는지는 잘 몰랐다. 책 읽으면서 간단하게 정리해보고자 한다.(reference : 자바 웹을 다루는 기술):heavy_check_mark: 내가 어렴풋이 알던 정의 :     클라이언트의 역할을 하면서 요청을 서버에 전달해주고 되돌려주는 일 하지만 서버에서 할 일도 조금 할 수 있는 거..?뭔가 대충 느낌은 아는데 그래서 어떻게 그게 가능하냐고 말하면 꿀먹은 벙어리가 되어버린다.일단 JSP 를 설명하기 위해 알아햐는 개념이 있다.:open_book: 동적 웹 프로그래밍과 정적 웹 프로그래밍란?:yellow_heart: 정적 웹 프로그래밍 :yellow_heart: 미리 웹 서버에 보여줄 html, css, js 들을 저장해놓고 요청 들어오면 출력해주는 방식이다.    여기서 필요한 요소는 웹 서버, 클라이언트, HTTP 프로토콜, 자바스크립트, css, html 등이 있다. 여기서 css 는 화면의 디자인적인 부분을 제어하고, js는 동적인 기능을 제공한다. 버튼 클릭하면 팝업창 뜨고 이런거.:purple_heart: 동적 웹 프로그래밍 :purple_heart:    매번 다른 정보주려면 업데이트하는 정적 방식의 불편함을 덜고자 웹 어플리케이션 서버를 배치하여 정보를 업데이트 해주는 관리자 역할을 시킨다.    초기 방식에서는 매 요청을 프로세스로 실행해서 , 같은 동작인데 처음부터 메모리에 로드하여 사용했다. 그래서 등장한게 스레드 방식으로 요청을처리하는 JSP 같은 웹 프로그래밍 기술이다.결국 요약하자면 JSP 는 스레드 방식으로 동작하는 동적 웹 프로그래밍 기술이다. 그럼 이제 동작 방식을 봐야겠다.:open_book: JSP 동작 과정    웹브라우저가 jsp 요청하면 jsp 파일은 jsp 컨테이너에 의해서 servlet 으로 변환된다.서블릿의 동작과정은 일단 요약하자면 서버에서 실행되다가 웹 브라우저 요청이 들어오면 해당 기능을 수행 후 결과 전송하는 역할을 한다.    원래는 서블릿 만으로 짜서 돌렸지만, 서블릿을 이용할 경우 브라우저에 결과물을 전달해줄때 HTML 태그들을 한땀한땀 그려서 전송해줘야하는 불편함이 있다.그래서 jsp 사용하고, 변환 단계는 다음과 같다.1) 변환 : JSP를 자바 파일로 변환2) 컴파일: 변환된 자바 파일을 컴파일해 클래스파일로 변환3) 실행: 클래스 파일 실행하여 그 결과물인 HTML, JS 등을 브라우저로 전달해 출력이런 과정을 통해 클라이언트 요청에 따른 서버의 작업 내용을 전달해준다.:open_book: JSP에서 동적 표현 제어하는 법    HTML 문을 사용할 때에는 정해진 태그에 따라서 행동하기에 사용자의 행동에 따른 동적인 제어가 불가능하다. JSP 에서는 동적 제어가 가능하도록 도와주는 요소들이 있다.1) 스크립트 요소 선언문 : 변수나 메서드 선언 &amp;lt;%! String name=”ㅎㅎ” %&amp;gt; 이런식 스크립트릿 : JSP 내에서 자바 코드 사용할 때 표현식 : 값을 출력 할 때 &amp;lt;%= name %&amp;gt; 이런 거2) 내장 객체 사용 jsp 가 서블릿으로 변환될때 자동으로 생성하는 객체들로 이를 이용해서 값도 전달하고 한다.-page : 한 요청이 들어오는 하나의 jsp 공유 (this )-request : 같은 요청을 공유하는 jsp 페이지 말한다-session : 같은 브라우저 내에서 공유-applicaiton : 같은 어플리케이션 내에서 공유    이렇게 정리를 하니까 과거에 그냥 쓰던 것들이 이런 의미였구나 깨닫게 된다.근데 요새 코딩을 별로 안하니까 진짜 다 까먹는 거 같다. 원래도 코딩 개코도 모르는데 이렇게 까먹어도 되나 싶네 ㅠㅇ ㅠ ….. 진짜로 코딩 좀 해봐야겠다…일단 jsp 정리는 여기서 끝 :100::100::100::100:" }, { "title": "Spring IoC container", "url": "/posts/spring-ioc-container/", "categories": "spring", "tags": "공부", "date": "2019-08-31 22:36:00 +0900", "snippet": "인생 쉽지 않다오늘은 Spring Framework - IoC container 에 대해서 적어보겠다.사실 그냥 문서 읽고 요약에 가깝겠지만 정리하는 김에 적는다. ㅠㅠㅠ    spring IoC container 의 기본은 org.springframework.beans, org.springframework.context 패키지 이다. 여기서 beanfactory 인터페이스를 기본으로 하여 application context 인터페이스가 구현된다. beanfactory 인터페이스는 프레임워크 설정과 구동의 기본 기능을 담당하고, application context 는 다른 레이어의 기능들을 이용하기 쉽도록 한 superset 과도 같다.IoC 컨테이너 간략 소개    IoC 컨테이너는 객체들을 인스턴스화 하고, 설정하고, 조립하는 일들을 하는데 이에 대한 정보들은 xml, java 어노테이션, 코드들로 이루어진 설정메타데이터를 보고 한다. 따라서 Application context 가 생성되고 초기화되면 어플리케이션/시스템에 대한 설정이 완료된 것이다.    설정 메타데이터들은 원래 xml 형식으로 되어있었는데, 스프링 3.0 이상에서는 빈들의 설정을 @어노테이션으로 해결한다. xml 베이스의 설정 메타 데이터는 &amp;lt;bean&amp;gt; 태그로 객체들 정의 나타낸다. 각 &amp;lt;bean&amp;gt; 태그에는 id 로 구분을 하고 class 속성으로 impl 가 어떤 내용인지 표현해준다.    IoC 컨테이너를 구동하기 위해서는 실제 설정 메타데이터가 어디 있는지를 알 수 있도록 명시해주어야 한다. 여러 메타데이터를 한번에 사용하기 위하여 &amp;lt;import&amp;gt; 태그를 사용하여 한 메타 데이터 설정파일에 다른 메타 데이터들을 얹어 놓기도 한다. 컨테이너의 가장 큰 역할은 시스템을 구성하는 객체 (beans) 를 조립해주는 것이기에 getBean 이라는 메소드를 통해 명시적으로 구동 시킬 수 있지만, 이상적인 작동방식은 getBean 없이 스스로 알아서 주입시키는 것이다.bean이란…?    bean들은 컨테이너에 메타 데이터를 제공해서 만들어진다. 컨테이너에서 참고하는 이런 정보들은 impl된 클래스, 행동 범위나 lifecycle 같은 설정, 다른 객체와의 의존성 관계 등등을 가져야 한다. bean을 인스턴스화 (실제 객체로 생성하는 방법)은 그냥 bean 설정을 쓰면 생성자로 알아서 생성해주는 방법도 있지만, static인 경우나 factory 패턴의 메소드를 이용하는 방법도 있다.질문 &amp;gt; bean 인스턴스화 하는 순서가 정확히 어떻게 되는거지? static은 왜 autowired 되지 않는 0걸까. : 인스턴스 생성 전에 static 은 만들어지니까 설정 메타 데이터 읽고 bean 만드는 과정은 그 후에 만들어져서 안되는듯 static0 이 문제 ㅠㅠ : 시스템 구동시에 constant 영역에 할당됨 그 후에 구동하면서 컨테이너가 bean 만들고 어쩌고 하는거라서 static 안됨Dependencies    DI 는 보통의 객체간의 의존관계 방식을 넣어주는 걸 말한다. 순서는 다음과 같다.1) 객체들은 의존관계를 지정한다.2) 컨테이너가 객체 bean 이 실제 생성될때, 의존 관계에 있는 것들을 넣어서 조립해준다.    이 과정을 컨테이너가 알아서 하기에 inversion of control 이라는 용어를 쓰는 것이다.bean 자체들이 인스턴스화되고, 어디에 들어가야 할지 알고 들어가게 되는 거다.이를 통해서 테스트 하기에도 쉽고 코드를 분리해내기에도 쉬워진다.    DI 방법에는 생성자 DI, setter DI 가 있다.뭐 당연히 이름처럼 생성자를 통해서 해당 객체 내에서 필요한(의존관계가 있는) 다른 객체를 넣어주는 거나, 아니면 setter 로 넣어주는 거다. 다른 객체를 bean 형식으로 넣어주는거 말고도, 123 같은 속성 값 자체를 넣어줄때는 타입이 문제가 된다.그래서 type=”int” 같은걸로 표현해줄 수도 있는데, 알아서 type 매칭 해주기도 한다.    이 두가지 DI 방법 중에 어떤걸 쓸지는 자기 마음이긴한데, 뭐 doc 에서는 꼭 필수적인 의존관계는 생성자로, 옵션같은건 setter 로 하라고 하는데 spring 에서는 setter 방식을 조금 더 추천하는 모양이다. (생성자에 arg를 주렁주렁 다는게 별로여서)DI 과정 ApplicationContext 가 생성되고 bean 들에 대한 정의를 가지고 있는 설정 메타 데이터를 보고 초기화된다. 각 bean들에 대한 의존 관계는 실제 bean 들이 생성될때 만들어진다. 의존 관계에 있는 속성들이 서로 다른 bean 들을 통해 세팅 된다. (의존관계 연결된다. ) 각 설정에 맞게 타입도 자동으로 변환된다.    여기서 주의할 점은 스프링 컨테이너는 구동시에 bean 설정을 점검하지만 실제로 의존관계 나 속성들이 세팅되는건 실제로 bean 이 생성될 때 라는 거다. 싱글턴 패턴인 bean 들이나, pre-init 설정된 bean 들은 컨테이너 구동시 만들어지지만, 아닌 bean 들은 bean 이 불릴때 생성된다.    이 특성 때문에, 실제로 속성들을 세팅할때 이미 컨테이너 가동 후에 에러를 발견할 수 있기 때문에 applicationcontext는 기본이 pre-init 이다. lazy-init 속성을 통해 bean 이 불릴때 생성되도록 해줄수는 있다.    의존 관계 설정같은건 뭐 string 자체를 넣어서 해줄 수 도 있고, null 이나 빈 값도 가능하다. property 세팅이나 constructor args 로 넣는 방법 쉽게 하기 위해서 c:~~ , p:~~~ 이런거 이싿는데 솔직히 여기서 처음봤다. ㅎㅎ 신기하네.그리고 bean 설정 파일에 depends-on 속성 통해서 명시적으로 의존 관계 표현해줄 수도 있다.autowire 속성을 통해서 applicationcontext 가 컨텐츠 보고 있다가 자동으로 연결해줄 수 도 있다. 주로 이름을 사용한다. 타입을 사용하는 경우도 있는데, 이때 타입이 명확히 하나로 정해지지 않고 해당 타입이 여러개 있으면 에러 발생시키기 때문이다.autowire 통한 field 주입의 단점    대충 보니까 평범하게 써왔던 그냥 의존관계 필요한 변수에 autowired 로 주입 시켜버리는걸 field 주입이라하고, 단점이 매우 많아서 피해야한다고 한다.이유를 조금 찾아보니, 세 가지가 있다.1) final 로 선언할 수 없다. (주입된 객체가 가변하는 성질을 가져 코드상 문제를 발생시킬 수 있다.)2) 테스트하기 불편하다. (코드 분리성이 떨어진다.)3) 의존 관계를 파악하기 어렵다. (순환 의존 관계에 대한 에러 파악 이런게 어렵다.)결론은 조금 더 똑똑하고 책임감있게 짜려면 constructor 버젼으로 해라 ^^ 아 하나 배웠다!!    이렇게 일단은 마무리 짓겠다. 좀 어렵긴한데, 확실히 doc 읽으니까 망나니였던 내 자신이 약간을 숙연해지는 효과가 있다 ^^인생 후르락끼 뚝딱뚜까딱~~~ 하던 내 모습 반성하게 되네요….bean scope 에 관한 아주 잘 정리된 글은 여기[https://gmlwjd9405.github.io/2018/11/10/spring-beans.html] 에서!!" }, { "title": "스프링을 구성하는 모듈 3- web module", "url": "/posts/spring-modules3-web/", "categories": "spring", "tags": "공부", "date": "2019-08-18 22:36:00 +0900", "snippet": "모든걸 다 해주는 기가 막힌 프레임워크가 있다?Web module 에 대해서 공부해 봐야겠다 ^^ Web module스프링 문서에서는 무슨 웹 지향적인 프로그램을 도와준다는데 웹 지향적,,,? 무슨 소리지.사실 웹 의 개념 자체를 잘 모르겠다. 웹 이 뭐지??? 그냥 인터넷 창 열고 하는게 웹 인가요?웹 간단히 인터넷에 연결된 사람끼리 정보를 주고 받을 수 있는 서비스인터넷과 혼용되고 있지만 웹은 인터넷의 한 서비스일 뿐이다.웹은 인터넷 상에서 텍스트나 그림, 소리, 영상 등과 같은 멀티미디어 정보를 하이퍼텍스트 방식으로 연결하여 제공합니다.하이퍼텍스트(hypertext)란 문서 내부에 또 다른 문서로 연결되는 참조를 집어 넣음으로써 웹 상에 존재하는 여러 문서끼리 서로 참조할 수 있는 기술을 의미합니다. 이때 문서 내부에서 또 다른 문서로 연결되는 참조를 하이퍼링크(hyperlink)라고 부릅니다. 출처    결론적으로는 머 웹서비스 위한 동작들은 해주는 모듈이군!스프링에서의 웹 모듈은 서블릿 리스너와 application context 통한 IoC 의 초기화를 담당한다고 한다.웹 서블릿 모듈은 MVC 모델의 구현에 사용되는데 진짜 애매하게 알고 있어서 이거 정리부터한다. 점점 정성이 사라지는 글,,,,서블릿이것도 역시 갓블로그 를 찾아서 봤다,,, 블로그 없으면 나는 블로그 못 써,,,, 서블릿이란 자바를 사용해 웹을 만들기 위한 기술로, 클라이언트에서 요청이 오면 그에 대한 결과를 전송해주는 역할을 한다.이 서블릿이 작동하기 위해서는 1) 사용자(클라이언트)가 URL을 클릭하면 HTTP Request를 Servlet Conatiner로 전송합니다.2) HTTP Request를 전송받은 Servlet Container는 HttpServletRequest, HttpServletResponse 두 객체를 생성합니다.3) web.xml은 사용자가 요청한 URL을 분석하여 어느 서블릿에 대해 요청을 한 것인지 찾습니다. 4) 해당 서블릿에서 service메소드를 호출한 후 클리아언트의 POST, GET여부에 따라 doGet() 또는 doPost()를 호출합니다. 5) doGet() or doPost() 메소드는 동적 페이지를 생성한 후 HttpServletResponse객체에 응답을 보냅니다. 6) 응답이 끝나면 HttpServletRequest, HttpServletResponse 두 객체를 소멸시킵니다.의 과정을 거쳐야한다고 하는데, 이걸 다 소스단에서 구성해주기 너무 귀찮다 ㅠㅠㅠMVC 패턴 관점에서 보면 서블릿은 컨트롤러 역할을 하는데, 이를 간단하게 구현 가능하도록 해주는게 웹 서블릿 모듈의 일이라고 이해했다.MVC     빡이 친다. 너무 싫다. MVC 짜증나. 물론 처음 배울땐 걍 뚝딱 이해해서 걍 대충 눈치로 보고 베끼기해서 뚝딱 대충 끼워넣고 잘 되는척 했는데,이제 그렇게 살 수 없잖아요,, 더 이상의 날로 먹기 no,,,,아주 간단하게 MVC 에 대해서 말 해보자면, Model: 데이터의 틀이 되어주는 것 (VO 같은거!)View: 화면단에 뿌려주는거 (jsp 같은거 ) Controller: 데이터 처리하는 로직 부분으로 서블릿의 역할로 view와 model 간의 징검다리가 되어준다.뭐 다 좋은말이긴 한데, 그래서 어떻게 동작하냐는거요,,,?Spring 에서는 DispatcherServlet 이 요청이 들어오면 해당 servlet 이 뭔지 찾아서 전달해주는 역할을 한다.1) 요청이 들어오면 요청 분석해 해당 서블릿에 요청 전달 2) 서블릿(controller) 는 요청에 따라서 데이터 처리한다. (HttpRequest 영역)3) 처리한 데이터를 model 의 형식으로 view 에 넘긴다. (HttpResponse 영역)4) view 에서는 데이터를 잘 뿌려준다.이걸 해주기 위해서 스프링해줘야 할 일.원래 서블랫 매핑을 기술해 줬던 web.xml 에 dispatcherservlet 등록 , url 필터 등록 같은걸 해줘야한다. 그리고 dispatcher 서블릿이 잘 알아볼 수 있도록 어노테이션으로 표기를 해주고, servlet-context.xml 에 componet-scan 범위를 넣어서어떤 컨트롤러들에 매핑시켜줘야하는지 해줘야한다.===================================================================================================================그 이외에도 portlet 같은게 있는데 찾아보니까 자주쓰는 웹 컴포넌트들을 정의해놓고 재사용하는 거 같은데써본적이 없어서 잘 와닿지가 않음. 몰라" }, { "title": "스프링을 구성하는 모듈 2- Data Access/Integration", "url": "/posts/spring-modules2-dao/", "categories": "spring", "tags": "공부", "date": "2019-08-17 22:36:00 +0900", "snippet": "모든걸 다 해주는 기가 막힌 프레임워크가 있다?이제 두번째 모듈 Data Access/Integration 차례다. Data Access/Integration이름에서 알 수 있듯이 데이터 관련된 처리를 해주는 모듈이다.JDBC나 트랜잭션 같은 DB 연결할때 자주 봤던 친구가 있는가하면, ORM, OXM, JMC ?? 얘네는 도대체 누구지..? 누구세요;;;;모르는 것들 정리하는김에 어렴풋이 알고 있는 JDBC 나 트랜잭션도 잡고 가야겠다 !JDBC JDBC란, 자바 언어로 다양한 종류의 관계형 데이터베이스에 접속하고 SQL문을 수행하여 처리하고자 할 때 사용되는 표준 SQL 인터페이스API입니다. JDBC는 자바의 표준 에디션에서 지원하는 기술로서, 접속하려는 DBMS 서버에 따라서 JDBC 드라이버가 필요합니다. https://opentutorials.org/module/3569/21222    저 블로그에 너무 잘 정리가 되어있다. JDBC 인터페이스를 작동시키기 위해서 인터페이스 구현체인 클래스를 JDBC 드라이버 라고 한다.작동을 위해 JDBC 드라이버를 메모리에 올리고, DB 연결을 하고 , 쿼리 구문을 쓰고, 결과값을 얻었다면 다시 연결을 해제하는 과정이 필요하다.    이 지겨운 과정을 대신해주는 역할을 하는게 바로 이 모듈이다. 프레임워크가 알아서 해줄테니 사용자는 설정값 입력, 쿼리 작성정도만 하면 원하는때 알아서 연결해서 데이터 가져오고 알아서 연결해제까지 해준다.스프링 프레임워크에서는 이 기능을 간편하게 하기 위해서 Mybatis 를 사용한다.그렇다면 mybatis 와 JDBC 의 차이점은 뭘까?Mybatis 는 JDBC 를 편하게 다루기 위한 라이브러리 이다. JDBC 의 단점은 다음과 같다. 같은 연결 코드를 여러번 중복해서 사용해야한다. 같은 파일 내에 자바 코드와 sql문이 혼용되어 있다. preparedstatement 같이 변수 들어가는 쿼리문을 사용자가 직접 준비하고 대입하는 코드 작성해야한다. 결과물을 java object 로 넣는 코드를 사용자가 짜야 한다.이런 불편함을 없애주는 라이브러리가 Mybatis 이다. 사용법도 간단하다. 사용법 예시를 찾아왔다.1) sql 쿼리를 StudentMapper.xml 파일에 작성한다. (일반적으로 쿼리 작성하는 xml 파일 이름 ~mapper.xml) INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(#{studId},#{name},#{email},#{dob})2) xml 파일과 동명의 인터페이스 생성한다.public interface StudentMapper{ Student findStudentById(Integer id); void insertStudent(Student student);}3) 자바 코드에서 불러와서 사용한다.SqlSession session = getSqlSessionFactory().openSession();StudentMapper mapper = session.getMapper(StudentMapper.class);// Select Student by IdStudent student = mapper.selectStudentById(1);//To insert a Student recordmapper.insertStudent(student);트랜잭션아 짜증난다. 너무 길어진다 ㅠㅠㅠ ㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋㅋ트랜잭션 관련해서도 또 정리 잘해논 블로그 찾았다 ㅎㅎ 지식보다 정보 찾는게 늘어가네 ㅎㅎ 2개 이상의 쿼리를 하나의 커넥션으로 묶어 DB에 전송하고 이 과정에서 어떠한 에러가 발생할 경우 자동으로 모든 과정을 원래 상태로 돌려놓는다. &amp;gt; 그야 말로 All Or Nothing 전략이다. by 블로그 주인분결국은 이 Data Access/Integration 모듈에서 트랜잭션 역할도 해준다는 건데, 그럼 도대체 어떻게 해주는거지?스프링에서의 트랜잭션 관련된 내용은 또 이 블로그 에 잘 나와있다. 나는야 지식 소매상~~~ 조금씩 떼다 써요~~~ORM관계형 데이터베이스 객체를 자바 객체로 매핑시켜주는 것으로 sql 쿼리를 직접 설정해야하는 mybatis 같은 mapper 기반 라이브러리와는 다르게 객체간의 관계로 sql을 자동으로 설정해준다. 블로그OXM Objext Xml Mapping 이라는 뜻으로 xml 을 자바 객체로 매핑시켜주는 역할을 한다. 음 사실 잘 이해가 안된다. 예시로 확 와닿는게 없어서 그런가. 머 marshalling 하고 serialization 한다 어쩌고 하는데 잘 모르겠다. 블로그 에서 찾은 marshalling serialization 차이부터 익혀야겠다. 회사 소스에서 post 로 파라미터 쏘기 전에 항상 serialization 하던데 이런 거 였구나. 마샬링은 추가적인 메타 데이터(코드 베이스)를 가질 수 있다는 점에서 직렬화와 구분된다.직렬화는 객체와 관계된 메소드를 포함하지 않고, 오브젝트에 있는 멤버 데이터만(코드 없이) 바이트 스트림에 써진다.마샬링에서는 오브젝트에 있는 멤버데이터 + 코드베이스가 전해진다.따라서 직렬화는 마샬링의 일부라고 할 수 있다." }, { "title": "스프링을 구성하는 모듈 1- Core Container", "url": "/posts/spring-modules1-corecontainer/", "categories": "spring", "tags": "공부", "date": "2019-08-17 22:36:00 +0900", "snippet": "스프링 프레임워크    POJO 를 사용하여 어플리케이션을 만들고, 엔터프라이즈 서비스를 비침투적으로 적용할 수 있도록 해주는 자바 플랫폼이다.    이렇게 말하니까 도대체 무슨 말인지 하나도 모르겠다. 하나씩 뜯어보자.    즉 사용자가 어플리케이션에만 집중할 수 있게 인프라를 다뤄주는데, 어플리케이션도 POJO ( getter 와 setter 로만 이루어진 클래스 구조 &amp;gt; 프레임워크 의존적이지 않음) 으로 구성할 수 있도록 해서 쓸데없는 일을 안하고 자기들끼리 지지고 볶겠다는 거 아닌가?    엔터프라이스 서비스에 비침투적으로 적용한다? 엔터프라이즈 서비스는 내가 보니까 여러 서비스를 하나로 묶어주는 구조를 엔터프라이즈 서비스 라고 하는 것 같다.    결국은 여러 서비스를 하는 커다란 엔터프라이즈 레벨 서비스 구현에서도 , 개발자는 이걸 어떻게 연결할지 고민할 필요 없이 POJO 를 사용해서 핵심 로직 구현에만 힘쓰면 된다는 말이지?모든걸 다 해주는 기가 막힌 프레임워크가 있다?이제 스프링의 구조를 좀 봐야겠다. 어떤 구조이길래 자기가 다 알아서 한다는거지? Core ContainerCore, Beans, Context, Expression Language 모듈이 있다. Core / Beans 모듈 : 프레임워크의 핵심에 해당하는 것으로 DI 할때 제 역할을 한다.BeanFactory 는 팩토리 패턴으로 구성되어 있고 싱글톤 패턴을 직접 구현할 필요가 없고, 의존성 설정과 구현 부분을 분리하는 역할을 한다. Context 모듈 : JNDI 와 비슷한 방식으로 프레임워크 안에서 동작한다.    엥? 이게 무슨 소리냐…? JNDI 도 뭔지 잘 모르는데 밑도 끝도 없이 무슨 JNDI 와 비슷한 방식입니까? JDNI 에 대해서는 이 포스트 참고 !!즉 다양한 리소스들을 가져다 쓸 때 참조하기 위한 모듈이라는 것이다. beans 모듈 특성들을 가지고 있지만 리소스 로딩 이나 EJB, JMX 같은 Java EE 의 기능도 가지고 있다. ApplicationContext 인터페이스 를 사용한다.** BeanFactory 와 ApplicationContext 차이기본적으로 ApplicationContext 는 BeanFactory 인터페이스 의 기능을 모두 가지고 있고 플러스 알파 기능이 있는 것이다. 주된 차이점은 다음과 같다. BeanFactory 는 getBean 메소드 호출시에 bean을 초기화하는데, applicationfactory 는 스프링 컨테이너 구동시에 초기화한다. ApplicationContext 는 어노테이션 기반 설정 처리 가능하다. (@Autowired 같은거) ApplicationContext 는 여러 설정파일 적용 가능하다. ApplicationContex 는 i18N 처리 가능하다. (다국어 처리) Expression Language 모듈 : 객체그래프 ( 객체 간의 참조 관계를 나타냄)을 표현하거나 쿼리를 표현하는 언어를 다루는 모듈이다. 속성값 설정이나 오퍼레이터, 설정상의 이름으로 컨테이너가 정보 찾도록 도와주는 역할을 한다.와 아직 모듈 하나 했네 ^^ 어렵다 어려버ㅠㅇ ㅠ글이 길어져서 모듈별로 나눠서 올려야겠다 !!" }, { "title": "IoC 와 DI", "url": "/posts/IoC-Dependency-Injection/", "categories": "spring", "tags": "공부", "date": "2019-08-17 22:36:00 +0900", "snippet": "사진으로 절벽에 매달린 나의 심정을 나타내봤다 ㅠㅠ…스프링 프레임워크를 공부하기로 마음 먹자마자 위기에 빠졌다.도대체 IoC 랑 DI 가 뭔데?블로그 변역글 에서 길게 얘기 했지만 무림식으로 요약해보겠다. 너무나도 방대해지고 무거워지는 Java EE 어플리케이션 을 탈피하고자 태초에 무림에는 여러 프레임워크들이 자웅을 겨루고 있었다. 그들에게 가장 기본적이고 중요한 해결과제가 있었으니… 바로 의존성을 어떻게 주입할 것인가 ! 여기서 나온 방법이 Inversion of Control (프레임워크가 정한 일정 규칙만 따르면 알아서 넣어줄게) 이고 이 IoC 의 작은 범위가 DI 라는 것이다.Inversion of Control    요약은 좋은데 너무 추상적인 말들이라고 해야하나? 궁금한 점을 차근차근 풀어보자.의존성을 주입하는 제어를 프레임워크에게 넘긴다라는 의미의 IoC 에서는 두 가지 중요한 단어가 있다.의존성 그리고 제어도대체 의존성이 뭐길래 넘기는지, 또 제어를 넘긴다는데 제어가 도대체 어디까지를 의미하는지 를 명확히 해야한다.의존성 간단히 말하면 A 에서 B를 new 하여 객체 생성하여 사용한다면 A는 B에 의존하고 있는 것이다. 두 모듈간의 연결성을 가지고 있다면 의존성이 있다고 한다.모든 고민의 시작은 어떻게 하면 new 하여 객체 인스턴스 생성 방법이나 뭐 싱글톤 같은 디자인 패턴 구현 없이 간단하게 의존성있는 객체를연결할 수 있을까 인 것 !!!    그러면 여기서 또 질문은 왜 간단히 new 하면 안될까? new 해서 객체를 생성한다면 의존성있는 한 모듈을 수정할 때 다른 모듈까지 수정해야한다. 늘상 예로 들어지만, 자동차 타이어 어쩌고를 한다면 한국타이어를 new 해서 사용했다면 금호 타이어로 바꾸기 위해선 타이어 호출 클래스도 수정해야한느데, DI 사용하면 주입 설정(bean 정의) 만 바꿔주면 다른 코드 수정없이 변경 가능하다. 이건 Dependency Injection 기능 뿐아니라 Reduce Dependency 의 역할도 한다. 상호간의 의존성을 낮추는 것이다.제어    여기서 프레임워크가 대신 해주겠다는 제어는 어디까지를 말하는걸까? IoC 에서 말하는 제어는 사용자는 코어한 로직만 제어하고 나머지는 다 프레임워크에서 한다. (구현 내용 대입 - 의존성 주입 같은 것들이나 프로그램 플로우를 제어해준다.) 그래서 DI 는 IoC의 부분집합이 되는 것이다. 프레임워크가 가져가는 제어중에 하나가 의존성 주입을 위한 객체 생성 및 라이프 사이클 제어이니까 그 제어하는 방법인 DI 가 따라 나온다. stackoverflow 에서 정리된 글이 도움이 됐다. 언제 어디서 제어 메소드가 호출되어 객체가 주입되고 흘러가는지는 다 프레임워크 단에 맡긴다. 그래서 간지나는 hollywood principle 이라는 말이 나왔다. 헐리우드 오디션처럼 “Don’t call us, we’ll call you” . 프레임워크에서 알아서 너의 코어 로직을 호출할게 ^^Dependency Injection신나게 얘기한 의존성 띄는 객체를 주입해주는 방법이 바로 Dependency Injection 이다.사용자가 할 일은 두 가지 이다.-주입하고자하는 정의를 담은 bean 설정파일 만들기. (xml)-주입되어야하는 위치에 어노테이션 하기컨테이너가 사용자가 작성한 bean 설정 파일을 보고 알아서 생성하고 알맞은 때에 알아서 넣어준다.spring 에서의 전달 방식은 아래 두 가지 있다. 생성자를 통한 전달 setter 통한 전달상세한 전달방식은 나중에 적겠다." }, { "title": "Inversion of Control Containers and the Dependency Injection pattern", "url": "/posts/inversion-of-control-blog-translate/", "categories": "spring", "tags": "공부", "date": "2019-08-15 22:36:00 +0900", "snippet": "    스프링 문서를 읽다가 IoC, DI 개념에 대한 추천 기사 를 읽었다. 공부할겸 번역 해보았다. ^^ 물론 의역 오역 천지지만 한글이 좋자나요?** Inversion of Control 과 Dependency Injection 은 번역 안함 (제어역전, 의존주입 &amp;gt; 말이 너무 어려워!)    자바 커뮤니티에서는 다른 프로젝트들에서 컴포넌트들을 연결해 결합력있는 어플리케이션으로 만들 경량 컨테이너들이 쏟아져나오고 있다.이런 컨테이너들이 컴포넌트들을 연결하는 방법은 주로 “Inversion of Control” 이라는 이름의 컨셉을 따랐다. 이 기사에서는 Dependency Injection 이라는 이름하의 패턴들이 다른 서비스 로케이터들과 다르게 작동하는지에 대해서 쓰겠다. 실제 구성 원리를 아는 것이 사용할 여러 방법론 옵션 중에 고르는 것보다 중요하다.    자바 엔터프라이즈 세계에서 흥미로운 건 J2EE 기술 메인스트팀의 제안을 제시하는 오픈소스 기반의 움직임들이다. 이 중 대다수는 J2EE 메인스트림의 복잡하고 덩치큰 기술들에 대한 반발이기도 하지만, 기발한 아이디어들을 제시하는 대안들이다. 주로 다뤄지는 이슈는 어떻게 다른 요소들을 연결하느냐 : 거의 서로 독립적으로 구성된 데이터베이스 인터페이스 구조를 가진 웹 컨트롤러를 연결하는것 이다. 여러 프레임워크들은 이 문제를 해결하고자 해왔고 component 들을 연결하는데 가능성을 보였다. 이런 프레임워크들은 (picoContainer,Spring 같은 ) 경량 컨테이너라고 불린다.Components 와 Services    The topic of wiring elements together drags me almost immediately into the knotty terminology problems that surround the terms service and component. You find long and contradictory articles on the definition of these things with ease. For my purposes here are my current uses of these overloaded terms.    I use component to mean a glob of software that’s intended to be used, without change, by an application that is out of the control of the writers of the component. By ‘without change’ I mean that the using application doesn’t change the source code of the components, although they may alter the component’s behavior by extending it in ways allowed by the component writers.    A service is similar to a component in that it’s used by foreign applications. The main difference is that I expect a component to be used locally (think jar file, assembly, dll, or a source import). A service will be used remotely through some remote interface, either synchronous or asynchronous (eg web service, messaging system, RPC, or socket.)    I mostly use service in this article, but much of the same logic can be applied to local components too. Indeed often you need some kind of local component framework to easily access a remote service. But writing “component or service” is tiring to read and write, and services are much more fashionable at the moment.Inversion of Control    이런 컨테이너들이 ‘Inversion of control’ 을 사용하기 때문에 스스로가 유용하다고 말할때, 나는 혼란스럽다. Inversion of Control 은 프레임워크의 흔한 특징이기에, IoC 를 사용해서 경량 프레임워크가 특별하다고 하는 것은 내 차가 바퀴가 있어서 특별하다고 말하는 것 과 다름없다.    진짜 질문은 “제어의 어떤 면을 뒤바꿨는가?” 이다. 내가 처음 IoC 를 접했을 때, IoC 가 역전한 건 유저 인터페이스였다. 초창기 유저 인터페이스는 어플리케이션에 의해 제어됐다. 프롬프트를 통해 “이름을 입력하세요. “ , “주소를 입력하세요” 같은 명령에 따라서 입력하면, 각각에 맞는 결과를 뽑아냈다. 그래픽적인 UI 와 UI 프레임워크는 다양한 화면에 맞는 이벤트 핸들러 대신, 이런 작업을 하는 메인 루프와 프로그램을 가지고 있었다. 메인 프로그램의 제어가 프레임워크로 역전된 것이다.    컨테이너들의 역전의 새로운 바람은 플러그인 구현을 어떻게 찾느냐에 있다. (즉 구현을 어떻게 반영시키느냐) 내 단순한 예제에서는 lister 가 바로 인스턴스 생성하여 finder 구현을 연결한다. 이건 finder 가 플러그인화 되는 것을 막는다. 이러한 컨테이너가 사용하는 접근방식은 별도의 모듈이 lister 에 구현을 주입할 수 있도록 하는 어떤 규칙을 사용자가 따르도록 하는 것이다. ( 이부분 번역이 너무 애매한데, 요약하자면 IoC 를 특징으로 하는 컨테이너들이 제어해주는건 lister 가 어떻게 구현을 주입할 수 있는지 자기들만의 법칙을 만들고 사용자는 이를 지키도록 한다. 이를통해 사용자는 프레임워크 규칙만 따르면 자기들이 알아서 구현을 넣어주는 역할을 한다는 것. 진심 문장 너무 어렵네;; ㅠ )이 결과로, 나는 이 패턴에 대해 조금 더 자세한? 상세한 이름이 있어야 한다고 생각한다. Inversion of Control 은 너무 포괄적인 단어이기에 사람들이 혼란스러워 하는 것 같다. 여러 논의끝에 우리는 Dependency Injection 이라는 단어에 정착했다.    I의 여러 방법들에 대해 언급할텐데, 나는 어플리케이션 클래스에서 플러그인으로 의존성을 제거하는 것만이 방법이 아니라는 것을 설명할 것이다. Service locator 라는 다른 패턴으로도 할 수 있는데 이건 DI 설명을 끝내고 덧붙이겠다." }, { "title": "VS Code 팁들", "url": "/posts/vscode_tips/", "categories": "기타", "tags": "VS Code, 미세먼지팁", "date": "2019-08-15 13:36:00 +0900", "snippet": "    사실 무료고, 설치가 간단해서 VS Code 를 사용중이긴 한데 여러 기능을 사용하진 않았다.    그냥 Exercism 문제 푸는데나 활용하고 말았지.근데 블로그 글을 markdown 으로 쓰고, 또 git 으로 관리하다보니까 이런 저런 기능늘이 필요해서 여러개 들쑤셨는데 알고보니 VS Code 에서 다 제공하는 기능이지 뭔가 ㅠㅠㅠ.역시 사람은 도구를 활용해야한다. 미세먼지같은 VS Code 팁~~~1. markdown preview     마크다운으로 글을 작성하다 보면, 퍼블리싱 했을때 어떻게 보일지 몰라서 몇번이나 수정하곤 했다. 그래서 stackedit 같은 온라인 마크다운 에디터를 사용했는데, vs code에서 이미 다 제공하는 기능이었다 ㅎㅎctrl + shift + v로 markdown preview 창 열 수 있음 !2. GIT 사용한 소스 관리     나는 여태까지 그냥 git bash 로 커맨드 창에서 해결해왔는데, vs code 내의 source control 사용해서 하니까 훨씬 간단하고 직관적이다. remote 설정한 로컬의 레파지토리 내에서 블로그 글 수정하고 사이드바를 보면 source control 에 변경사항 기록된 것 확인할 수 있다.    변경사항을 클릭하면 compare 창 나타나서 어떻게 수정됐는지도 확인할 수 있다. stage 로 바로 올리고 싶으면 changes 옆으로 마우스를 올리면 , + 기호 보인다. 이걸 누르면 바로 staged 된다. 그리고 커밋 메세지 입력하고 ctrl+enter 누르면 바로 커밋된다. push 는 … 메뉴 클릭 후 push 하면 된다 ! 너무 간단해부러,,,이건 내가 참고한 블로그에 정말 잘 정리되어 있다. ^^" }, { "title": "Spring Email Sender", "url": "/posts/spring-mailsender/", "categories": "study", "tags": "공부", "date": "2019-08-15 13:36:00 +0900", "snippet": "Spring Email Sender스프링에서 제공하는 MailSender 로 쉽게 메일 전송하는 방법https://www.baeldung.com/spring-email1) 필요한 library 받기 pom.xml 에 dependency 설정으로 받아도 되고, jar 파일 다운 받아서 톰캣 경로/lib 에 넣어줘도 된다.&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spring-context-support&amp;lt;/artifactId&amp;gt;&amp;lt;version&amp;gt;5.0.1.RELEASE&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;jar 파일 받는 경로 -&amp;gt; 클릭lib 내 인터페이스 정리 MailSender interface: 제일 상위 인터페이스 JavaMailSender interface: MIME 메세지를 보내는데 도움이 되는 인터페이스로 주로 MimeMessageHelper 와 함께 사용한다. JavaMailSenderImpl class: implement 내용 정의된 클래스 SimpleMailMessage class: 송수신 정보, 간단한 텍스트 내용, 참조 정보들 기본적인 메일 메시지 구현하는 클래스 MimeMessagePreparator interface: MIME 메세지 구현 위한 인터페이스 MimeMessageHelper class: MIME 메세지 구현내가 해본 예제는 간단히 텍스트만 보내기에 JavaMailSender + SimpleMailMessage 조합이다.2. JavaMailSenderImpl 의존 주입위해 spring context 파일 수정 &amp;lt;bean id=”mailSender”class=”org.springframework.mail.javamail.JavaMailSenderImpl”/&amp;gt;3. MailSender 속성 세팅 mailSender.setHost(&quot;smtp.gmail.com&quot;);mailSender.setPort(587);mailSender.setUsername(&quot;my.gmail@gmail.com&quot;);mailSender.setPassword(&quot;password&quot;);Properties props = mailSender.getJavaMailProperties();props.put(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;);props.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;);props.put(&quot;mail.debug&quot;, &quot;true&quot;); 속성 세팅을 위해 각 속성이 의미하는 바를 알아야한다. 걍 뚝딱 세팅하니까 메일이 안가네...(당연한 말) - [ ] setHost : 메일을 전송해주는 메일 서버 - [ ] setPort: 포트 번호 세팅인데, 25, 587, 465 등이 있다. 25 : 옛날 표준 방식으로 요즘은 잘 쓰이지 않는다. relay (메일서버에서 다른 메일 서버로 수신 메일함 없으면 전달 &amp;gt; 스팸 메일의 원흉이 됨) 가 가능한 메일 서버에서 사용하던 포트로 요즘은 잘 쓰이지 않지만 레거시들이 남아있어서 사용된다. 587: TLS 와 함께 사용되는 현재 표준 포트 번호이다. 어지간한 메일 서버의 포트번호 465: IANA 가 발표했던 메일 표준 포트번호, SSL의 포트번호로 레거시들에 남아있음. 출처: Which SMTP Port Should I Use? Understanding Ports 25, 465, &amp;amp; 587 [https://www.mailgun.com/blog/which-smtp-port-understanding-ports-25-465-587] - [ ] setUserName, Password : 메일 서버에 인증할 로그인 정보 (서버에 올려서 같은 내부 서버 내에서 메일 전송할때는 인증 정보 쓸 필요 없다. ) - [ ] getJavaMailProperties 세팅 : mail.smtp.starttls.enable &amp;gt; TLS 사용 여부 mail.smtp.auth &amp;gt; 인증 사용 여부mail.debug &amp;gt; 메일 전송 내용 디버깅해 콘솔에 출력4. 메일 내용 세팅 @Autowiredpublic JavaMailSender emailSender;public void sendSimpleMessage (String to, String subject, String text) {&amp;gt; SimpleMailMessage message =new SimpleMailMessage();&amp;gt; message.setTo(to); message.setSubject(subject); message.setText(text); emailSender.send(message);}     솔직히 너무 간단해서 할 말이 없다.. ㅠㅠ 닉값 한다 진짜 simplemailmessage.. 진짜 simple…. 파일 같은 걸 같이 보내고 싶을 땐 attachement 로 보내면 되는데 이것 또한 한 simple 하니 baeldung 참고해서 보내면 된다.    근데 attachement 말고 전자 서명같은 인라인 첨부가 필요할 때가 있다. 첨부 이미지긴한데 첨부파일 목록에 들어가지 않고 메일 본문에 나와야하는 경우. 이때는 MimeMessageHelper.addAttachment() 사용하여 인라인 첨부에 CID 부여하여 사용한다.@Service public class EmailService { @Autowired private JavaMailSender emailSender; public void sendSimpleMessage(Mail mail) throws MessagingException { MimeMessage message = emailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message,MimeMessageHelper.MULTIPART_MODE_MIXED_RELATED, StandardCharsets.UTF_8.name()); helper.addAttachment(&quot;logo.png&quot;, new ClassPathResource(&quot;memorynotfound-logo.png&quot;)); // addAttachment(CID 값, path) String inlineImage = &quot;&amp;lt;img src=\\&quot;cid:logo.png\\&quot;&amp;gt;&amp;lt;/img&amp;gt;&amp;lt;br/&amp;gt;&quot;; helper.setText(inlineImage + mail.getContent(), true); helper.setSubject(mail.getSubject()); helper.setTo(mail.getTo()); helper.setFrom(mail.getFrom()); emailSender.send(message); }} 출처: [https://memorynotfound.com/spring-mail-sending-email-inline-attachment-example/](https://memorynotfound.com/spring-mail-sending-email-inline-attachment-example/)배웠던 메일 전송 플로우랑 SMTP 에 대해서 조금 더 공부해서 정리해야겠다." }, { "title": "Javascript this 바인딩 1 [객체 내부 메서드 호출과 함수 호출]", "url": "/posts/java-script-this-binding/", "categories": "study", "tags": "공부", "date": "2019-08-10 13:36:00 +0900", "snippet": "함수 호출 방식에 따라서 this 인자는 다른 객체를 참조한다.    JS 로 Exercism 문제를 풀고 있는데 이 개념을 정확히 안 잡고 가니까 자꾸 엉뚱한데에서 헤맸다. 이것도 정리해봐야겠다. ( 인사이드 자바스크립트 책 참고)    그래서 결국 어떻게 호출되었는지 상관없이 똑같이 행동하는 bind 가 나오게 되었다. 이거는 뭐 this 헷갈리는건 만국 공통이었다 이거구만.1. 객체가 내부 메서드 호출시객체 내부의 메서드 프로퍼티를 호출할때 this 는 해당 메서드를 호출한 객체로 바인딩된다. var myObject ={ name: &#39;foo&#39;, sayName: function(){ console.log (this.name); // 객체의 내부 메서드 sayName // 객체 myObject 의 name } }; var otherObject={ name : &#39;bar&#39; }; otherObject.sayName = myObject.sayName; myObject.sayName(); otherObject.sayName(); ======================================= foo bar 두 번의 sayName 메서드가 호출한 객체의 name 으로 바인딩 된 것을 확인할 수 있다. 2. 함수 호출시의 this    함수 호출시에는 this 가 전역 객체에 바인딩 된다. node.js 같은 환경 이용할 땐 전역 객체는 global, 브라우저 실행시에는 window 객체 바인딩 된다.변수명을 정의할 때 잘 정의해야하는 이유가 되기도 한다. (window 객체 이름이랑 중복되면 바인딩 시 에러의 원인이 되니까)    여기까지는 이해가 쉬웠는데 내부함수를 호출할 경우 부터 개념이 헷갈리기 시작했다. 내부 함수에 this 를 사용한다면, 내부 함수 호출도 함수 호출 패턴으로 인식되기에 전역 객체에 바인딩 된다.    그래서 책에서는 this 값을 저장하는 that 변수를 따로 이용해서 거기에 접근하도록 하지만, bind 함수를 사용해서 해결 가능하다. var value = 100; var myObject={ value=1, func1: function(){ var that=this; //that 변수에 this 저장함으로써 접근 가능 this.value+=1; console. log (this.value) ; // 2 func2: function(){ that.value+=1; //3 console.log(that.value); } func2(); } }; myObject.func1(); ======================================= 2 3호출 주체의 중요성을 느낄 수 있다.    누가 실행했냐에 따라서 this 의 주체가 달라진다.단순히 매핑시켜놓은 것과는 무관하고 호출 시기가 중요하다.그래서 언제 누가 호출해도 같은 방식이 되도록 bind하는 방식이 나왔다.위의 예제를 bind 활용해서 바꾸면 다음과 같다. var value = 100; var myObject={ value: 1, func1: function(){ this.value+=1; console. log (this.value) ; // 2 func2= function(){ this.value+=1; //3 console.log(&quot;func2 &quot;+this.value); }.bind(this) // func1 의 this (myObject) 를 바인딩시켜 같은 value 가리키도록 func2(); } }; myObject.func1(); " }, { "title": "github 블로그 수정 사항 변경 방법", "url": "/posts/githubblog-start/", "categories": "기타", "tags": "미세먼지팁", "date": "2019-08-10 13:36:00 +0900", "snippet": "git 다루는게 어색하기에 아주 간단한 글 수정, Config 변경에도 애를 먹었다.너무 기본적이긴 하지만 나같은 초보자를 위해 정리해둔다.레파지토리 복사    일단 repository 하나 파서 블로그를 띄우고 나면, 파일 수정이 용이하기 위해서 로컬에 복사하는 과정이 필요하다.repository &amp;gt; clone or download &amp;gt; download zip 으로 복사 OR git bash 로 git clone 한다!파일 수정다양한 마크다운 에디터들을 이용해서 수정할 수 있지만, 나는 귀찮아서 VS code 로 수정했다.파일 커밋 하기파일을 수정했다면 커밋 과정을 통해서 수정된 파일을 반영해야한다. git add &amp;gt; 수정한 파일을 stage 에 올리기 위해 사용한다. 간단하게 git add –all 로 전체 올려버린다. ignore 할게 없어서 그냥 그렇게 했다. git add 파일명 으로 해도 된다. git commit &amp;gt; 커밋을 통해 변경사항을 내 로컬에 저장한다. 아직 서버 repository 에는 반영된게 아니다. git commit -m “커밋메세지” (git commit -am “커밋메세지” 로 1의 과정 생략 가능하다. ) git push &amp;gt; 서버 repository 에 반영하기 위한 과정이다. **git push origin master ** (git push -u origin master -u는 서버 레파지토리 업뎃 후 push » 블로그는 그냥 혼자 쓰니까 굳이 -u 하지 않았다.) 반영된 모습 확인하기아주 뿌듯한 과정이다 :) 히히왕초보인 나에게는 이렇게 간단한 과정도 참 험난했다.그냥 있는 에디터 사용할걸 왜 굳이 깃헙블로그 만들고 있나 현타도 왔지만 그래도 이것또한 공부라고 생각한다 !!앞으로 열심히 정리해야지!" } ]
