---
layout: post
title:  Big O 표기법에 대하여
date:  2022-04-15 13:05
img:  # Add image post (optional)
categories: [study]
tags: [IT,  java, algorithm] # add tag
sitemap :
changefreq : daily
priority : 1.0
---

udemy에서 인강을 들은거 바로 블로그에 정리해야겠다.   
내가 듣는 인강은 [이거](https://www.udemy.com/course/master-the-coding-interview-data-structures-algorithms/) 입니다.  


# 1. Big O 표기법 사용하는 이유 

어떤게 좋은 코드고 알고리즘인지 판단하기 위해서는 이게 수행될때 얼마만큼의 시간적, 공간적(물리적) 자원을 잡아먹는지를 봐야한다.  

이게 왜 중요하냐면 아무리 우리가 이미 구현된 언어 내의 util 을 가져다 쓴다고 하더라고 각 util (기본 ds라고 치자)의 big O를 대강이라도 알고 성능을 고려해가면서 짜는 코드랑 그냥 되네 ㅎ 하고 짜는 코드는 천지차이이기 때문이다.    

그러기 위해서는 어떻게 big O 를 계산하는지를 알아야한다.  

# 2. Big O  계산법 

- 시간복잡도 : 수행하기위해서 얼마나 많은 operation 을 거쳐야하는지   
시간복잡도를 늘리는 것들은 +, - 같은 단순 연산, 비교, loop, 함수 호출등이 있다. 

### O(N) - 입력인자 수 N 만큼 선형적으로 증가한다. N이 커지면 정비례하여 증가 .
~~~java
public void linear(int n){
    for(int i=0; i<n; i++){
        System.out.println(i);
    }

    // 수행하기 위해선 n 번만큼의 동작이 필요하고 input 과 정비례한다. 
    // n= 10, 20 일땐 상관 없지만 n 이 기하급수적으로 커진다면... ? 
}

~~~
### O(1) - input 에 상관 없이 늘 같은 공간복잡도 
~~~java
public void linear(int n){
    for(int i=0; i<10; i++){
        System.out.println(i);
    }
    // n 과 상관없이 늘 10번만 돈다 ! 
}

~~~

O(N^2) - 컬렉션의 모든 값이 다른 값과 비교할때. nested loop 2개짜리 일때 발생하면서 N이 늘어나면 급경사로 operation 갯수 늘어남 

- 공간복잡도 : 메모리를 얼마나 사용하는지에 관한 계산이다. 
어떤 동작을 수행할 때마다 배열을 새롭게 생성해야한다던지 하면 공간복잡도가 늘어나는것. (메모리 쓰니까), 아니면 메소드를 호출해야한다던지 (스택이 쌓임)


# 3.Big O 계산시 규칙 
- 항상 최악의 케이스를 생각하라.  경우에 따라서 운좋게 찾는 값이 배열 앞쪽에 위치한다던지 해서 복잡도를 줄일 수 있다고 생각하지 말기. 
- 상수값을 제거한다.  O(2n) 같이 쓰지 말고 상수 날리기
- 서로 다른 input 은 같은 인자로 치지 않는다.  O(n+m)처럼 가야함.  nested loop 만 곱한다. 
- 결정적이지 않은 값들은 제외한다. O(n^2+3n+1) 이면 n이 증가함에 따라서 가장 큰 영향을 주는 것만 남겨놓는다. O(n^2) 