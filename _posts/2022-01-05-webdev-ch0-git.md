---
layout: post
title: WebDevCurriculum 0강 Git
date:  2022-01-05 19:05
img: git.png # Add image post (optional)
categories: [webDev]
tags: [IT,  web, Git, 협업툴, 형상관리툴] # add tag
sitemap :
changefreq : daily
priority : 1.0
---
[https://github.com/Knowre-Dev/WebDevCurriculum] 를 따라 해보려고 한다.   
시간이 얼마나 걸릴지는 모르지만 일단 열심히 끝까지 따라가는걸 목표로 하려구요 !   
개인적으로 대기업 SI 출신 개발자로써 내가 그다지 시장에서 큰 매력이 없는거 같다.   
내가 스타트업에서 개발자로 한 사람분을 한다는 걸 보여주려면 적어도 온보딩 프로그램 완주정도의 지식은 가지고 들어가야할 것 같아서 시작했다. 

우선 블로그는 기본적으로 베어에 공부하면서 정리한 걸 올리는 용도로만 써야겠다.   
같은 내용의 기록이 산발적으로 있어야할 필요는 없어서 그냥 백업용임.  

---

# Q1. 형상관리 시스템은 왜 나오게 되었을까요?   
형상관리 시스템은 점점 복잡해지는 시스템을 개발하면서  통일성을 갖추기 위해 만들어졌으며 IT 에 국한되어있지 않고 토목 등 다른 여러 가지 엔지니어링에도  사용되는 용어이다.   
IT 에 있어서 형상관리 시스템이란  소프트웨어 메타 데이터의 변화를 따라가며 추적할 수 있고, 버전 관리 와 CI/CD 와 함께 쓰인다.   
즉 점점 복잡해지는  시스템 소프트웨어의 변경사항을 체계적으로 관리하기 위해 만들어지게 되었다.  변경 관리와 버전관리를 모두 포함한 내용으로 단순히 소스의  관리 뿐 아니라  db 와 서버 연결 설정 등 환경 설정에 대한 내용도 관리 대상으로 포함되어있다.   

# Q2. git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요?   분산형 형상관리 시스템이란 무엇일까요?  
Git 은 분산형 형상관리 시스템이다.  
형상관리 시스템에는  중앙집중형과 분산형이 있다.  중앙집중형의 대표격인게 svn , TFS 이다.   이건 중앙서버에 소스가 있고  개개인의 개발자는 그 중앙의 소스를 내려받고  변경사항을 다시 올린다.  이때  중앙 서버가 내려가면 소스가 분실된다는 위험이있다.  
분산형은  각 개발자의  로컬 pc 에 소스를 내려받아 각자가  로컬 서버 역할을 한다.  중앙서버가 내려가도 각자의 로컬 pc 의 소스를 싱크 맞추면 복구 가능하다.    

내가 이전 회사에 있었을 땐 svn과 TFS 만 썼었다.   그래서 한 사람이 수정하기 위해 체크아웃하여 소스가 잠겨 있어서 병합 작업 중에 전화 걸어서 해당 소스 체크아웃되어있다고 연락하던 기억이 있다.  그땐 이런 차이점을 잘 몰라서 그런가보다 했는데  git 같은 분산형 시스템이었다면 그런 일 없었을 듯 !!   

# Q3. git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요? 
리눅스 커널을 개발하던 개발자들이 비트 키퍼라는 형상관리 시스템을 쓰다가  갈등을 빚어 비트키퍼가 더 이상 무료 제공을 안하겠다고  선언하자 자체 형상관리 툴을 만들었다.     무료이고, 속도가 빠르며 , 여러개의 브랜치에서 동시 다발적인 개발을 하는데  적합한  형상관리 시스템을 목표로 만들어졌다. 여러명의 개발자가 커뮤니티에서 소통하면서  원격으로 개발하는 환경을 위해 만들어졌기에 , 분산형을 채택할 수 밖에 없던 환경이었다.  

# Q4. git과 GitHub은 어떻게 다를까요?  
Github 은 git 의 원격 저장소를 호스팅해주는 도구이다. 로컬에서 수정한 내용을 업로드하여 공유 가능하도록 호스팅해주는 것이다.  
Git 은 로컬 저장소에서 각자 사용하는 형상관리 시스템 이고 , github 은 본인의 로컬 pc에서 git을 통해 형상관리한 내용을 클라우드 서버에  호스팅해 공유하고 다른 사람과의 협업이 쉽도록 도와주는 것이다.  
나는 이 둘을 혼용해왔는데 이번 기회에 제대로 개념을 잡게 되었다.  
git 을 통해 형상 관리하는 소스를 github으로 호스팅해 공유받은 커리큘럼을 공부 중이군!  

# Q5. git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?
*git clone* :  기존에 존재하는 레포지토리를 본인의 로컬에 받아올 때 사용.  분산형 시스템이기에  체크아웃이 아닌 클론으로 복사본을 만드는 의미이다.   

*git add*  :  작업하고 있는 로컬 디렉토리와  git 저장소 변경 이력 사이의 장소인 스테이징 영역에  현재 작업중인 변경 내용을 올리는 작업이다.   커밋할  준비가 된 변경 내용이  git 저장소에  기록되기 전 대기하는 장소에 올리는 것이다. 
 - git add  .    :  현재 디렉토리의 모든 변경내용을 올림
 - git add 파일/디렉토리 경로 : 이 경로의 파일만 올림 
 - git add -A :  작업 디렉토리 안의 모든 변경 내용을  포함   

*git commit* :  현재 변경되어 스테이징에 올라가있는 변경사항에 대한 스냅샷을 남긴다.  이때 스냅샷은 로컬 레퍼지토리에만 남을뿐이고,  나중에 푸시해서 원격 저장소에 올릴 수 있다.   (스냅샷 : 특정 시점에서 파일, 폴더 스트럭쳐, 태그,  커밋 등의 상태를 그대로 저장하는것 ). 이게 svn 같은 중앙집중형과의 차이점, svn 에서 커밋은 git 에 있어서 푸시까지 한 상태이다.  중앙 레퍼지토리에 반영된 상태이기에.   

- git commit -a  ( 스테이징의 모든 변경사항을 커밋함) 
- git commit - m “커밋 메시지”  커밋 메시지까지 쓰고 올림 

*git push* :   로컬 레퍼지토리에 커밋해둔걸  원격 저장소에 올리는  커맨드 
- git push "remote repo" "branch"     

*git pull* : fetch 와 merge 가 합쳐진 형태로,  처음엔 원격저장소에 있는 변경분을  다운 받고 그다음에 로컬의 변경분과 로컬에 반영 안되어있는 원격의 변경분을 로컬 내 디렉토리에 merge 한다.  

- git pull " 원격 저장소명"    
  >  이렇게 하면   git fetch <원격저장소명>  한 다음에  git merge origin/ <현재 로컬브런치> 한 것과 같다.  현재 head 와 pull 하면서 머지되어 새로 생긴  부분 만큼 차이가 생겨 새로운 커밋이 생기기에  새 머지 커밋 생긴다. 이를 생기지 않게 하지 위에서는 아래 두가지 방법이 있다.  
- git pull —no-commit <원격저장소명>
- git pull —rebase <원격저장소명> : rebase 통해  헤드 옮기는 개념
---
**풀리퀘스트 관련 추가 공부**
 
Fork 나 클론해와서 마스터 권한 없는 거에서 수정하는 경우, 
브랜치 생성 -> 커밋 -> 푸시 -> 관리소 에서 풀리퀘스트 생성 버튼 활성화  
-> 내용 적어 활성화 함 ->  마스터 권한 인 사람이  승인해주면 pull  받아와야한다!!  

멋대로 마스터에 푸시하는걸 막기 위함임 ㅎㅎ 
현업에서 수정할 때 쓰는 방법이다.  
내 브랜치 따서 수정하고 풀리퀘스트 보내기 !!!   

---
*git branch* : 동시에 독립적으로 어떤 작업을 진행하기 위해  서로 다른 버전의 작업이 되도록 하는 브랜치를 생성하는 방식이다.    
- git branch <branch명>   :   브랜치 생성함 
- git branch -d  <branch>  :  브랜치 삭제함 (  머지 안된 변경사항 있으면 삭제 ㄴ) 
- git branch -D <branch> :   강제로 브랜치 삭제함 
- git branch -a : 모든 브랜치 리스트업
  
*git stash*:  현재 변경 상태를 저장해놓고 최근 커밋한 상태로 돌아갈때 사용.   
현재 뭔가 변경하면서 고치고 있는데 급한 픽스 버전을 올려야할 때 사용한다. 고치고 있는건 저장해놓고 ,  이전의 배포 완료한 버전으로 돌아가서 긴급 픽스만 다시 올리기 !!  이런식으로 사용.   
- git  stash  : 저장하기
- git stash save "메모" : 세이브에 메모 저장해놓기    
- git stash list  : 저장된 목록보기
- git stash apply :    가장 최근의 내용 저장
- git stash pop :  적용 후 리스트에서 삭제함 
- git stase clear :   전체 삭제 
- git stash branch  "새로 만들 브런치 이름" stash@숫자  스테이시 내용으로 브런치 생성되고 생성된 브런치로 체크아웃되며 스테이시는 삭제됨   
stash@숫자   ->  stash list 에서  확인 가능 

# Q6, git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?
*object*  :   git 이 파일을 관리하기 위해  만드는 것들   
.git/objects  폴더에 저장되어 있다.  git 은 모든 파일을 오브젝트로 관리하며,  파일의 텍스트 내용도 커밋내용도 다 오브젝트로 만들어서 관리하는 것이다 !!   
그래서  특정 시점에서 변경된 부분을 저장하기에 스냅샷을 찍는다고 한다.   작은 부분만 수정해도 텍스트의 전체 내용을 저장하는 오브젝트를 만들기에 .git/pack 폴더에 주기적으로 압축해서 놓는다. 
git 은 내부에  commit, tree, blob, tag 4가지 오브젝트 타입이 있다.   

- blob :  텍스트 내용 저장함 (파일명에 대한 정보는 없다.
- tree:    파일명 +  해당하는 blob 오브젝트 SHA-1 값
- commit :   tree sha-1 값.     Author, committer , commit 메시지 저장 
- tag :  태그 값 

*tag* :  커밋을 참조하기 쉽도록 알기 쉬운 이름을 붙여주는 것이다.   
               이름 정보만을 갖는 태그 와  상세 정보를 포함하는 주석 태그  두 가지가 있다. 
커밋하고 나서 git tag [태그 이름] 으로 붙일 수 있다.  주석 태그는 git tag -a  [긴 태그]
태그를 원격 저장소에 올리려면 git push origin tag명 한다. 
Git tag 하면 태그 리스트 볼 수 있음. 

*branch* :  변경 사항을  여러 버전으로 만드는 느낌 으로,  커밋들 사이를 이동할 수 있는 포인터 개념이다.  기본적으로 git 은 master 브랜치를 만든다.   커밋을 만들면 마스터 브랜치는 자동으로 가장 마지막 커밋을 가리킨다.   

*Head* : 현재 체크아웃된 커밋 , 즉 현재 작업중인 커밋으로 현재 작업중인 로컬 브랜치를 가리킨다.    Git branch 명령으로는    브랜치가 옮겨지진 않고 checkout 명령어로 브랜치 사이를 이동한다.   

# Q7.리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요? 

Git revert  통해서 되돌린다.   메인 저장소에  원하지 않는 파일 올라갔을 때는 git reset 으로 리셋 가능하지만 리모트인 경우 는  revert 사용함.   

*git reset* :   나만 해당 브랜치를 사용할 경우  사용.    
- Git reset —hard 하는 경우는  돌이킨 이후의 반영 내용은 모두 사라진다.   
- Git reset —mixed  변경 이력은 삭제하지만 언스테이징 상태로 변경 이력은 남아있어 원하는 부분만   add 하면 된다.  
- Git reset —soft 하면 변경 이력은 삭제되어있지만 변경했던 내용은 스테이지드 되어있음  

*git revert*  :  커밋을 추가하여  삭제하고자 하는 커밋을 삭제한다는 기록을 남긴다.  
해당 커밋 내용만 삭제된다.    git revert 커밋해시 하면 이 커밋을 삭제하겠다는 내용도 바로 커밋된다.    그러지 않기 위해서는  git revert —no-commit [되돌리고자하는 커밋해쉬] 해서 스태이지 상태로만 유지함. 

--- 
**참고**   
[git add 기본 개념/사용법 | Engineering Blog by Dale Seo](https://www.daleseo.com/git-add/)  
https://www.atlassian.com/git/tutorials/saving-changes/git-commit  
[git stash 임시저장 사용하고 응용하기](https://velog.io/@byeol4001/git-stash-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0)  
[Git Internals 정리 :: Git은 어떻게 동작할까?](https://coding-groot.tistory.com/68)  
[Git - 브랜치란 무엇인가](https://git-scm.com/book/ko/v2/Git-%EB%B8%8C%EB%9E%9C%EC%B9%98-%EB%B8%8C%EB%9E%9C%EC%B9%98%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80)



